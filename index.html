<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Dawn">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dawn">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dawn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Dawn</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dawn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/访问网站流程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/访问网站流程/" itemprop="url">访问网站流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T14:31:35+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><ul>
<li><strong>浏览器缓存</strong></li>
<li><strong>系统缓存</strong></li>
<li><strong>路由器缓存</strong></li>
<li><strong>ISP的DNS缓存</strong></li>
<li><strong>根域名服务器搜索</strong></li>
<li><strong>获得IP</strong></li>
</ul>
<h2 id="Http数据包"><a href="#Http数据包" class="headerlink" title="Http数据包"></a>Http数据包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成http数据包</span><br><span class="line">GET http://www.baidu.com/ HTTP/1.1</span><br><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Zune 4.7; InfoPath.3; MS-RTC LM 8)</span><br><span class="line">Accept-Encoding: gzip, deflate, peerdist</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Cookie: BDSFRCVID=H1K_JgC2l434o0a3SlYrhIyDwFLxPM7C3J; H_BDCLCKID_SF=tJAt_C8htDv5HTuRj63D5JcH-UnLqMkDWaOZ0h8-aI-5MbAx-jb6hhFXM-r80nblBTbT2C3nthF0HPonHj8Bej5L3J; BAIDUID=C0E879D1A40237E70E9FA559D40EE0AC:FG=1; BDUT=w5n3C0E879D1A40237E70E9FA559D40EE0AC13914a661370; BDUSS=FEQVdNdjllMTYyYlRxY3ZZbW1hM2htemdqZFVJcWRLWmFBaEtqd1FoTDNXeE5SQUFBQUFBJCQAAAAAAAAAAAoqyysAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEwLjI2LjE5Ny43NwAAAADAxFInAAAAAPcNJlD3DSZQYV; BDRCVFR[eYjbPwSqvSs]=2g3v5sBI-NCpv4EILPoXi4WUvY; Hm_lvt_9f14aaa038bbba8b12ec2a4a3e51d254=1344671219756; Hm_lpvt_9f14aaa038bbba8b12ec2a4a3e51d254=1344671219756</span><br><span class="line">X-P2P-PeerDist: Version=1.0</span><br></pre></td></tr></table></figure>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>TCP 数据包需要设置端口，接收方的Http端口默认是 80,本机的端口是一个1024-65535之间的随机整数。</p>
<p>首先通过TCP三次握手建立连接,通过TCP四次挥手断开连接。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%85%A8%E6%B5%81%E7%A8%8B_1.png" alt="image"></p>
<h2 id="TCP三次握手-建立连接"><a href="#TCP三次握手-建立连接" class="headerlink" title="TCP三次握手(建立连接)"></a>TCP三次握手(建立连接)</h2><ol>
<li><strong>第一次握手:</strong> 客户端发送SYN(syn=x)包到服务器,并进入SYN_SEND状态,等待服务器确认</li>
<li><strong>第二次握手:</strong> 服务器接收到syn包,必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包(syn=y),即SYN+ACK包,此时服务器进入SYN_RECV状态</li>
<li><strong>第三次握手:</strong> 客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,完成三次握手</li>
<li>握手过程中传送的包里不包含数据,三次握手完毕后,客户端和服务端才开始传送数据。理想状态下,TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将一直保持下去</li>
</ol>
<h2 id="TCP四次挥手-释放连接"><a href="#TCP四次挥手-释放连接" class="headerlink" title="TCP四次挥手(释放连接)"></a>TCP四次挥手(释放连接)</h2><p>断开一个TCP连接需要四次挥手</p>
<ol>
<li><strong>第一次挥手:</strong> 主动关闭方发送一个FIN，关闭主动方到被动方的数据传送</li>
<li><strong>第二次挥手:</strong> 被动关闭方收到FIN包后，发送ACK给对方</li>
<li><strong>第三次挥手:</strong> 被动关闭方发送一个FIN，关闭被动方到主动方的数据传送</li>
<li><strong>第四次挥手:</strong> 主动关闭方收到FIN后，发送一个ACK给对方，至此完成四次挥手</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>IP数据包需要知道双方的IP地址,IP数据包由头部()IP 地址信息) + TCP 数据包组成。</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>ARP通过IP地址获得MAC地址,数据帧由头部(MAC地址) + 数据组成。</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>将数据链路层的帧数据转换为bit流。</p>
<h1 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h1><ul>
<li>bit流转换为帧</li>
<li>帧转换为IP数据包</li>
<li>IP数据包转换为TCP数据包</li>
<li>TCP数据包转换为HTTP数据包</li>
<li>生成相应的requst、response对象</li>
<li>生成响应发送客户端</li>
</ul>
<h1 id="客户端收到服务器响应数据"><a href="#客户端收到服务器响应数据" class="headerlink" title="客户端收到服务器响应数据"></a>客户端收到服务器响应数据</h1><ul>
<li>解析response</li>
<li>浏览器根据响应渲染页面</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/OkHttp源码详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/OkHttp源码详解/" itemprop="url">OkHttp源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T21:53:46+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文基于OkHttp 3.12.0版本</strong></p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_OkHttp%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_1.png" alt="image"></p>
<h1 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h1><h2 id="创建OkHttpClient"><a href="#创建OkHttpClient" class="headerlink" title="创建OkHttpClient"></a>创建OkHttpClient</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用Builder模式创建OkHttpClient</span><br><span class="line">public OkHttpClient() &#123;</span><br><span class="line">    this(new OkHttpClient.Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// OkHttpClient中的一些参数</span><br><span class="line">public Builder() &#123;</span><br><span class="line">    // 分发器</span><br><span class="line">    this.dispatcher = new Dispatcher();</span><br><span class="line">    // 协议</span><br><span class="line">    this.protocols = OkHttpClient.DEFAULT_PROTOCOLS;</span><br><span class="line">    // 传输层版本与连接协议</span><br><span class="line">    this.connectionSpecs = OkHttpClient.DEFAULT_CONNECTION_SPECS;</span><br><span class="line">    this.eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">    // 代理选择</span><br><span class="line">    this.proxySelector = ProxySelector.getDefault();</span><br><span class="line">    if (this.proxySelector == null) &#123;</span><br><span class="line">        this.proxySelector = new NullProxySelector();</span><br><span class="line">    &#125;</span><br><span class="line">    // cookie</span><br><span class="line">    this.cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">    // socket工厂</span><br><span class="line">    this.socketFactory = SocketFactory.getDefault();</span><br><span class="line">    // 主机名字确认</span><br><span class="line">    this.hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">    // 证书链</span><br><span class="line">    this.certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">    // 代理身份验证</span><br><span class="line">    this.proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">    // 本地身份验证</span><br><span class="line">    this.authenticator = Authenticator.NONE;</span><br><span class="line">    // 连接池</span><br><span class="line">    this.connectionPool = new ConnectionPool();</span><br><span class="line">    // 域名</span><br><span class="line">    this.dns = Dns.SYSTEM;</span><br><span class="line">    // 安全套接层重定向</span><br><span class="line">    this.followSslRedirects = true;</span><br><span class="line">    // 本地重定向</span><br><span class="line">    this.followRedirects = true;</span><br><span class="line">    // 尝试连接失败</span><br><span class="line">    this.retryOnConnectionFailure = true;</span><br><span class="line">    this.callTimeout = 0;</span><br><span class="line">    // 默认连接超时时间</span><br><span class="line">    this.connectTimeout = 10000;</span><br><span class="line">    // 默认读取超时时间</span><br><span class="line">    this.readTimeout = 10000;</span><br><span class="line">    // 默认写入超时时间</span><br><span class="line">    this.writeTimeout = 10000;</span><br><span class="line">    this.pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发起同步请求"><a href="#发起同步请求" class="headerlink" title="发起同步请求"></a>发起同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 发起一个同步的网络请求</span><br><span class="line">okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 调用了newCall返回一个RealCall对象</span><br><span class="line">Call newCall(Request request) &#123;</span><br><span class="line">        return RealCall.newRealCall(this, request, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 实际调用在RealCall的execute()方法</span><br><span class="line">Response execute() throws IOException &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (this.executed) &#123;</span><br><span class="line">            // 每个call只能执行一次</span><br><span class="line">                throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.executed = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.captureCallStackTrace();</span><br><span class="line">        this.timeout.enter();</span><br><span class="line">        this.eventListener.callStart(this);</span><br><span class="line"></span><br><span class="line">        Response var2;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 通知dispatcher执行call</span><br><span class="line">            this.client.dispatcher().executed(this);</span><br><span class="line">            // 通过一系列拦截操作,实际进行网络请求并且获取结果(责任链模式)</span><br><span class="line">            Response result = this.getResponseWithInterceptorChain();</span><br><span class="line">            if (result == null) &#123;</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var2 = result;</span><br><span class="line">        &#125; catch (IOException var7) &#123;</span><br><span class="line">            IOException e = this.timeoutExit(var7);</span><br><span class="line">            this.eventListener.callFailed(this, e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        // 通知dispatcher执行完毕</span><br><span class="line">            this.client.dispatcher().finished(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">       List&lt;Interceptor&gt; interceptors = new ArrayList();</span><br><span class="line">       // 用户自定义的拦截器</span><br><span class="line">       interceptors.addAll(this.client.interceptors());</span><br><span class="line">       // 负责失败重试以及重定向的拦截器</span><br><span class="line">       interceptors.add(this.retryAndFollowUpInterceptor);</span><br><span class="line">       // 负责将用户请求转换为服务器的请求以及将服务器的响应转换为用户友好响应的拦截器</span><br><span class="line">       interceptors.add(new BridgeInterceptor(this.client.cookieJar()));</span><br><span class="line">       // 负责读取、更新缓存的拦截器</span><br><span class="line">       interceptors.add(new CacheInterceptor(this.client.internalCache()));</span><br><span class="line">       // 负责和服务器建立连接的拦截器</span><br><span class="line">       interceptors.add(new ConnectInterceptor(this.client));</span><br><span class="line">       if (!this.forWebSocket) &#123;</span><br><span class="line">           // 用户自定义的网络拦截器</span><br><span class="line">           interceptors.addAll(this.client.networkInterceptors());</span><br><span class="line">       &#125;</span><br><span class="line">       // 负责向服务器发送请求数据以及读取响应的拦截器</span><br><span class="line">       interceptors.add(new CallServerInterceptor(this.forWebSocket));</span><br><span class="line">       Chain chain = new RealInterceptorChain(interceptors, (StreamAllocation)null, (HttpCodec)null, (RealConnection)null, 0, this.originalRequest, this, this.eventListener, this.client.connectTimeoutMillis(), this.client.readTimeoutMillis(), this.client.writeTimeoutMillis());</span><br><span class="line">       // 开启链式调用(责任链模式)</span><br><span class="line">       return chain.proceed(this.originalRequest);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line">        StreamAllocation streamAllocation = new StreamAllocation(this.client.connectionPool(), this.createAddress(request.url()), call, eventListener, this.callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line">        // 如果未canceled则一直循环</span><br><span class="line">        while(!this.canceled) &#123;</span><br><span class="line">            boolean releaseConnection = true;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 责任链模式 调用下一个拦截器 并且捕获异常进行操作</span><br><span class="line">                response = realChain.proceed(request, streamAllocation, (HttpCodec)null, (RealConnection)null);</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">            &#125; catch (RouteException var19) &#123;</span><br><span class="line">                if (!this.recover(var19.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">                    throw var19.getFirstConnectException();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException var20) &#123;</span><br><span class="line">                boolean requestSendStarted = !(var20 instanceof ConnectionShutdownException);</span><br><span class="line">                if (!this.recover(var20, streamAllocation, requestSendStarted, request)) &#123;</span><br><span class="line">                    throw var20;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed((IOException)null);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder().priorResponse(priorResponse.newBuilder().body((ResponseBody)null).build()).build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            Request followUp;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 构建重定向请求</span><br><span class="line">                followUp = this.followUpRequest(response, streamAllocation.route());</span><br><span class="line">            &#125; catch (IOException var18) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw var18;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Util.closeQuietly(response.body());</span><br><span class="line">            ++followUpCount;</span><br><span class="line">            if (followUpCount &gt; 20) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!this.sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = new StreamAllocation(this.client.connectionPool(), this.createAddress(followUp.url()), call, eventListener, this.callStackTrace);</span><br><span class="line">                this.streamAllocation = streamAllocation;</span><br><span class="line">            &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 赋值为新的重定向请求</span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1L) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, Util.hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // gzip压缩</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = this.cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, this.cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 责任链模式 调用下一个拦截器</span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">        HttpHeaders.receiveHeaders(this.cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">        okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);</span><br><span class="line">        if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            // gzip解压</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder().removeAll(&quot;Content-Encoding&quot;).removeAll(&quot;Content-Length&quot;).build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        // cache利用DiskLruCache进行磁盘缓存</span><br><span class="line">        Response cacheCandidate = this.cache != null ? this.cache.get(chain.request()) : null;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        CacheStrategy strategy = (new Factory(now, chain.request(), cacheCandidate)).get();</span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">        if (this.cache != null) &#123;</span><br><span class="line">            this.cache.trackResponse(strategy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            Util.closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            return (new Builder()).request(chain.request()).protocol(Protocol.HTTP_1_1).code(504).message(&quot;Unsatisfiable Request (only-if-cached)&quot;).body(Util.EMPTY_RESPONSE).sentRequestAtMillis(-1L).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">        &#125; else if (networkRequest == null) &#123;</span><br><span class="line">            return cacheResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Response networkResponse = null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // 责任链模式 调用下一个拦截器</span><br><span class="line">                networkResponse = chain.proceed(networkRequest);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">                    Util.closeQuietly(cacheCandidate.body());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            if (cacheResponse != null) &#123;</span><br><span class="line">                if (networkResponse.code() == 304) &#123;</span><br><span class="line">                    response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</span><br><span class="line">                    networkResponse.body().close();</span><br><span class="line">                    this.cache.trackConditionalCacheHit();</span><br><span class="line">                    this.cache.update(cacheResponse, response);</span><br><span class="line">                    return response;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Util.closeQuietly(cacheResponse.body());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</span><br><span class="line">            if (this.cache != null) &#123;</span><br><span class="line">                if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">                    CacheRequest cacheRequest = this.cache.put(response);</span><br><span class="line">                    return this.cacheWritingResponse(cacheRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        this.cache.remove(networkRequest);</span><br><span class="line">                    &#125; catch (IOException var13) &#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        // 使用httpcodec处理请求,其实现类http1codec与http2codec分别对应着HTTP/1.1 和 HTTP/2 版本的实现</span><br><span class="line">        // httpcodec内部使用Okio对Socket的读写操作进行了封装,Okio对io以及nio进行了封装,可以进行更加便捷高效的io操作</span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(this.client, chain, doExtensiveHealthChecks);</span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line">        // 责任链模式 调用下一个拦截器</span><br><span class="line">        return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 使用httpcodec处理request获取response</span><br><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        RealConnection connection = (RealConnection)realChain.connection();</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        long sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">        httpCodec.writeRequestHeaders(request);</span><br><span class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line">        Builder responseBuilder = null;</span><br><span class="line">        if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</span><br><span class="line">            if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">                httpCodec.flushRequest();</span><br><span class="line">                realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">                responseBuilder = httpCodec.readResponseHeaders(true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseBuilder == null) &#123;</span><br><span class="line">                realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">                long contentLength = request.body().contentLength();</span><br><span class="line">                CallServerInterceptor.CountingSink requestBodyOut = new CallServerInterceptor.CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">                realChain.eventListener().requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">            &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpCodec.finishRequest();</span><br><span class="line">        if (responseBuilder == null) &#123;</span><br><span class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">        int code = response.code();</span><br><span class="line">        if (code == 100) &#123;</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">            response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        realChain.eventListener().responseHeadersEnd(realChain.call(), response);</span><br><span class="line">        if (this.forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0L) &#123;</span><br><span class="line">            throw new ProtocolException(&quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="发起异步请求"><a href="#发起异步请求" class="headerlink" title="发起异步请求"></a>发起异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 异步请求示例</span><br><span class="line">okHttpClient.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onFailure(Call call, IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(Callback responseCallback) &#123;</span><br><span class="line">        // 不允许重复调用</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (this.executed) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.executed = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.captureCallStackTrace();</span><br><span class="line">        this.eventListener.callStart(this);</span><br><span class="line">        this.client.dispatcher().enqueue(new RealCall.AsyncCall(responseCallback));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将请求加入到一个队列中</span><br><span class="line">void enqueue(AsyncCall call) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            this.readyAsyncCalls.add(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.promoteAndExecute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">boolean promoteAndExecute() &#123;</span><br><span class="line">        assert !Thread.holdsLock(this);</span><br><span class="line"></span><br><span class="line">        List&lt;AsyncCall&gt; executableCalls = new ArrayList();</span><br><span class="line">        boolean isRunning;</span><br><span class="line">        AsyncCall asyncCall;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            Iterator i = this.readyAsyncCalls.iterator();</span><br><span class="line"></span><br><span class="line">            while(true) &#123;</span><br><span class="line">                if (i.hasNext()) &#123;</span><br><span class="line">                    asyncCall = (AsyncCall)i.next();</span><br><span class="line">                    if (this.runningAsyncCalls.size() &lt; this.maxRequests) &#123;</span><br><span class="line">                        if (this.runningCallsForHost(asyncCall) &lt; this.maxRequestsPerHost) &#123;</span><br><span class="line">                            i.remove();</span><br><span class="line">                            executableCalls.add(asyncCall);</span><br><span class="line">                            this.runningAsyncCalls.add(asyncCall);</span><br><span class="line">                        &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                isRunning = this.runningCallsCount() &gt; 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = 0;</span><br><span class="line"></span><br><span class="line">        for(int size = executableCalls.size(); i &lt; size; ++i) &#123;</span><br><span class="line">            asyncCall = (AsyncCall)executableCalls.get(i);</span><br><span class="line">            // 在线程池中执行call的execute()方法</span><br><span class="line">            asyncCall.executeOn(this.executorService());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/mynameishuangshuai/article/details/51303446" target="_blank" rel="noopener">OkHttp官方教程解析-彻底入门OkHttp使用</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列：拆 OkHttp</a></li>
<li><a href="https://juejin.im/entry/597800116fb9a06baf2eeb63" target="_blank" rel="noopener">OkHttp解析</a> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/Glide源码详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/Glide源码详解/" itemprop="url">Glide源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-09T22:15:59+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文基于Glide 4.5.0版本</strong></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Volatile + Double-Checked Locking实现Glide的单例</span><br><span class="line">public static Glide get(@NonNull Context context) &#123;</span><br><span class="line">    if (glide == null) &#123;</span><br><span class="line">      synchronized (Glide.class) &#123;</span><br><span class="line">        if (glide == null) &#123;</span><br><span class="line">          checkAndInitializeGlide(context);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过构建者模式构造Glide</span><br><span class="line">Glide glide = builder.build(applicationContext);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// GlideBuilder的build方法返回Glide</span><br><span class="line">return new Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptions.lock(),</span><br><span class="line">        defaultTransitionOptions);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Glide的几个重要的构造参数如下:</p>
<ul>
<li><strong>arrayPool 数组池</strong></li>
<li><strong>memoryCache 内存缓存</strong></li>
<li><strong>bitmapPool 图片池</strong></li>
<li><strong>engine 引擎类</strong></li>
</ul>
<h2 id="ArrayPool"><a href="#ArrayPool" class="headerlink" title="ArrayPool"></a>ArrayPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定arrayPool则使用默认的Lru缓存策略</span><br><span class="line">if (arrayPool == null) &#123;</span><br><span class="line">      // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定memoryCache则使用默认的Lru缓存策略</span><br><span class="line">if (memoryCache == null) &#123;</span><br><span class="line">    // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">  memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BitmapPool"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定memoryCache则使用默认的缓存策略</span><br><span class="line">if (bitmapPool == null) &#123;</span><br><span class="line">      int size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">      if (size &gt; 0) &#123;</span><br><span class="line">      // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">        bitmapPool = new LruBitmapPool(size);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      // 不做缓存</span><br><span class="line">        bitmapPool = new BitmapPoolAdapter();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemorySizeCalculator"><a href="#MemorySizeCalculator" class="headerlink" title="MemorySizeCalculator"></a>MemorySizeCalculator</h2><h3 id="ArrayPool缓存池大小"><a href="#ArrayPool缓存池大小" class="headerlink" title="ArrayPool缓存池大小"></a>ArrayPool缓存池大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 缓存池大小取决于当前是否为低内存机型</span><br><span class="line">// 默认大小为4MB,如果当前为低内存机型则缓存池设为2MB</span><br><span class="line">arrayPoolSize =</span><br><span class="line">    isLowMemoryDevice(builder.activityManager)</span><br><span class="line">        ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR</span><br><span class="line">        : builder.arrayPoolSizeBytes;</span><br></pre></td></tr></table></figure>
<h3 id="BitmapPool与MemoryCache缓存池大小"><a href="#BitmapPool与MemoryCache缓存池大小" class="headerlink" title="BitmapPool与MemoryCache缓存池大小"></a>BitmapPool与MemoryCache缓存池大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取可用内存大小</span><br><span class="line">getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,</span><br><span class="line">      float lowMemoryMaxSizeMultiplier) &#123;</span><br><span class="line">    // 每个进程最大可用内存</span><br><span class="line">    final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;</span><br><span class="line">    final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);</span><br><span class="line">    // 如果是低内存手机 则最大内存*0.4 否则为最大内存*0.33</span><br><span class="line">    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier</span><br><span class="line">        : maxSizeMultiplier));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取屏幕宽度    </span><br><span class="line">int widthPixels = builder.screenDimensions.getWidthPixels();</span><br><span class="line">// 获取屏幕高度</span><br><span class="line">int heightPixels = builder.screenDimensions.getHeightPixels();</span><br><span class="line">// 当前屏幕宽度*屏幕高度*4</span><br><span class="line">int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;</span><br><span class="line">// 图片缓存池大小为屏幕尺寸大小*4(若当前版本大于等于Android O,则直接为屏幕尺寸大小*1)</span><br><span class="line">int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);</span><br><span class="line">// 内存缓存大小为屏幕尺寸大小*2</span><br><span class="line">int targetMemoryCacheSize = Math.round(screenSize *builder.memoryCacheScreens);</span><br><span class="line">// 可用内存为可用内存大小减去ArrayPool缓存池大小</span><br><span class="line">int availableSize = maxSize - arrayPoolSize;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否超过最大值,否则就等比缩小</span><br><span class="line">if (targetMemoryCacheSize + targetBitmapPoolSize &lt;= availableSize) &#123;</span><br><span class="line">      memoryCacheSize = targetMemoryCacheSize;</span><br><span class="line">      bitmapPoolSize = targetBitmapPoolSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      float part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">      memoryCacheSize = Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">      bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定engine则使用默认的engine</span><br><span class="line">if (engine == null) &#123;</span><br><span class="line">      engine =</span><br><span class="line">          new Engine(</span><br><span class="line">              memoryCache,</span><br><span class="line">              diskCacheFactory,</span><br><span class="line">              diskCacheExecutor,</span><br><span class="line">              sourceExecutor,</span><br><span class="line">              GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">              GlideExecutor.newAnimationExecutor(),</span><br><span class="line">              isActiveResourceRetentionAllowed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>engine的几个重要参数:</p>
<ul>
<li><strong>memoryCache 内存缓存</strong></li>
<li><strong>diskCacheFactory 本地缓存</strong></li>
<li><strong>diskCacheExecutor 本地缓存线程池</strong></li>
<li><strong>sourceExecutor 处理源资源线程池</strong></li>
</ul>
<h3 id="MemoryCache-1"><a href="#MemoryCache-1" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><p>同上。</p>
<h3 id="DiskCacheFactory"><a href="#DiskCacheFactory" class="headerlink" title="DiskCacheFactory"></a>DiskCacheFactory</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Factory &#123;</span><br><span class="line">  // 默认大小为250MB</span><br><span class="line">  int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 *</span><br><span class="line">  // 默认缓存目录为image_manager_disk_cache</span><br><span class="line">  String DEFAULT_DISK_CACHE_DIR = &quot;image_manager_disk_cache&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DiskCacheExecutor"><a href="#DiskCacheExecutor" class="headerlink" title="DiskCacheExecutor"></a>DiskCacheExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">newDiskCacheExecutor() &#123;</span><br><span class="line">    return newDiskCacheExecutor(</span><br><span class="line">    // 默认可获得处理器大小为1</span><br><span class="line">        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,</span><br><span class="line">        DEFAULT_DISK_CACHE_EXECUTOR_NAME,</span><br><span class="line">        UncaughtThrowableStrategy.DEFAULT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SourceExecutor"><a href="#SourceExecutor" class="headerlink" title="SourceExecutor"></a>SourceExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可获得处理器大小为当前可用处理器大小与4的最小值</span><br><span class="line">bestThreadCount =</span><br><span class="line">          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());</span><br></pre></td></tr></table></figure>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><h2 id="with的重载"><a href="#with的重载" class="headerlink" title="with的重载"></a>with的重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 返回一个RequestManager对象</span><br><span class="line">  * @see #with(android.app.Activity)</span><br><span class="line">  * @see #with(android.app.Fragment)</span><br><span class="line">  * @see #with(android.support.v4.app.Fragment)</span><br><span class="line">  * @see #with(android.support.v4.app.FragmentActivity)</span><br><span class="line">  */</span><br><span class="line"> @NonNull</span><br><span class="line"> public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">   return getRetriever(context).get(context);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步生命周期"><a href="#同步生命周期" class="headerlink" title="同步生命周期"></a>同步生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 通过传递Context类型的不同执行相似的逻辑</span><br><span class="line">RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">      if (context instanceof FragmentActivity) &#123;</span><br><span class="line">        return get((FragmentActivity) context);</span><br><span class="line">      &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">        return get((Activity) context);</span><br><span class="line">      &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">        return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 以传递Context类型为activity为例代码如下</span><br><span class="line">// 其他类型逻辑类似 都是获取FragmentManager</span><br><span class="line">get(@NonNull Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      return fragmentGet(activity, fm, null /*parentHint*/);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个无界面的Fragment,让请求和activity的生命周期同步</span><br><span class="line">fragmentGet(@NonNull Context context,</span><br><span class="line">      @NonNull android.app.FragmentManager fm,</span><br><span class="line">      @Nullable android.app.Fragment parentHint) &#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">      // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 如果在子线程调用或者传入Context类型为application,则请求与Application生命周期同步</span><br><span class="line">RequestManagerRetriever(@Nullable RequestManagerFactory factory) &#123;</span><br><span class="line">    this.factory = factory != null ? factory : DEFAULT_FACTORY;</span><br><span class="line">    handler = new Handler(Looper.getMainLooper(), this /* Callback */);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private RequestManager getApplicationManager(@NonNull Context context) &#123;</span><br><span class="line">    // Either an application context or we&apos;re on a background thread.</span><br><span class="line">    if (applicationManager == null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        if (applicationManager == null) &#123;</span><br><span class="line">          // Normally pause/resume is taken care of by the fragment we add to the fragment or</span><br><span class="line">          // activity. However, in this case since the manager attached to the application will not</span><br><span class="line">          // receive lifecycle events, we must force the manager to start resumed using</span><br><span class="line">          // ApplicationLifecycle.</span><br><span class="line"></span><br><span class="line">          // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  new ApplicationLifecycle(),</span><br><span class="line">                  new EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以加载文件图片为例,将返回一个RequestBuilder对象,支持链式调用</span><br><span class="line">RequestBuilder&lt;Drawable&gt; load(@Nullable File file) &#123;</span><br><span class="line">    return asDrawable().load(string);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="into"><a href="#into" class="headerlink" title="into"></a>into</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">into(@NonNull ImageView view) &#123;</span><br><span class="line">    // into方法必须要在主线程调用,否则抛出异常</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    RequestOptions requestOptions = this.requestOptions;</span><br><span class="line">    // 未调用transform而且设置了scaleType则会对图片做处理</span><br><span class="line">    if (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != null) &#123;</span><br><span class="line">      switch (view.getScaleType()) &#123;</span><br><span class="line">        case CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_CENTER:</span><br><span class="line">        case FIT_START:</span><br><span class="line">        case FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER:</span><br><span class="line">        case MATRIX:</span><br><span class="line">        default:</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return into(</span><br><span class="line">        // 将View封装为Target</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        /*targetListener=*/ null,</span><br><span class="line">        requestOptions);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">into(</span><br><span class="line">      @NonNull Y target,</span><br><span class="line">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">      @NonNull RequestOptions options) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    if (!isModelSet) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options = options.autoClone();</span><br><span class="line">    // 构建request</span><br><span class="line">    Request request = buildRequest(target, targetListener, options);</span><br><span class="line"></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    // 如果存在之前的相同请求而且未设置不允许内存缓存</span><br><span class="line">    if (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      // 释放当前request以及相关资源</span><br><span class="line">      request.recycle();</span><br><span class="line">      // 如果请求完成,将重新开始请求</span><br><span class="line">      // 如果请求正在运行,则继续运行</span><br><span class="line">      if (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        // 直接使用之前的请求来进行优化操作</span><br><span class="line">        // 例如跳过设置占位符,跟踪与取消跟踪目标,获取view尺寸</span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除target之前的request</span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    // 绑定request</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    // 跟踪request</span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runRequest(Request request) &#123;</span><br><span class="line">    // 加入request列表</span><br><span class="line">    requests.add(request);</span><br><span class="line">    if (!isPaused) &#123;</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 最终进入到Engine的load()</span><br><span class="line">// 尝试从ActiveResources中获取</span><br><span class="line">// ActiveResources中存放一个弱引用的map,存储使用中的资源,为了防止内存不足清除cache后不影响使用中的资源</span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    if (active != null) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">// 如果ActiveResources未能获取到则到MemoryCache中获取</span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 如果获取到则直接返回</span><br><span class="line">EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    if (current != null) &#123;</span><br><span class="line">      current.addCallback(cb);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return new LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line">// 创建engineJob</span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line">            </span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    // 启动decodeJob</span><br><span class="line">    engineJob.start(decodeJob);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start(DecodeJob&lt;R&gt; decodeJob) &#123;</span><br><span class="line">    this.decodeJob = decodeJob;</span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">    // 尝试从磁盘中获取</span><br><span class="line">    // 磁盘获取的逻辑模式为先尝试获取处理后的图片然后尝试获取原图</span><br><span class="line">        ? diskCacheExecutor</span><br><span class="line">    // 从网络中获取</span><br><span class="line">        : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/08/Glide和Picasso对比/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/Glide和Picasso对比/" itemprop="url">Glide和Picasso对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-08T21:07:44+08:00">
                2018-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Glide和Picasso是目前Android开发中很流行的图片加载库，Glide库和Picasso库也有极大的相似性，其区别主要体现在如下几个方面。</p>
<h1 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h1><p>Glide库的大小要远远大于Picasso。<br><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Glide%20%E5%92%8C%20Picasso%E5%AF%B9%E6%AF%94_1.png" alt="image"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>Glide支持gif</li>
<li>Glide支持视频略缩图</li>
<li>Glide支持与Acitivty生命周期联动</li>
<li>Glide默认加载<strong>RGB_565</strong>(2字节),Picasso默认加载<strong>ARGB8888</strong>(4字节)</li>
<li>Glide提供了更多配置可供定制化</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ul>
<li><strong>Picasso:</strong> 下载图片然后在本地缓存完整图片。如果需要resize,也是对原图进行resize。</li>
<li><strong>Glide:</strong> 下载图片,然后改变图片大小以适应不同需求,最后缓存到本地。同一张图片如果不同ImageView加载可能缓存多张图片。</li>
</ul>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>由于Glide缓存改变大小后的图片,而Picasso缓存原图,所以Glide使用的内存要小于Picasso。</p>
<h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><p>由于缓存机制的不同,Picasso从缓存中读取原图要先resize,而Glide则直接读取缓存图片,所以加载速度Glide优于Picasso。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/wait-notify机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/wait-notify机制/" itemprop="url">wait/notify机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T17:26:02+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="wait-notify机制介绍"><a href="#wait-notify机制介绍" class="headerlink" title="wait/notify机制介绍"></a>wait/notify机制介绍</h1><p>当一个线程A调用了对象o的wait()方法而进入了等待状态,而另一个线程B调用了对象o的notify()/notifyAll()方法,线程A收到通知退出等待队列,进入可执行状态。</p>
<h2 id="wait-notify机制的用处"><a href="#wait-notify机制的用处" class="headerlink" title="wait/notify机制的用处"></a>wait/notify机制的用处</h2><p>当两个线程存在生产者消费者关系,如果用轮询实现会造成资源的浪费,而wait/notify可以解决这个问题。</p>
<h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><ul>
<li><strong>notify():</strong> 随机唤醒等待队列中等待统一资源的一个线程,此线程会进入可运行状态</li>
<li><strong>notifyAll():</strong> 使所有等待队列中等待同一共享资源的线程退出等待队列,进入可运行状态</li>
<li><strong>wait():</strong> 调用该方法的线程释放锁并且从运行状态退出,进入等待队列,直到被唤醒</li>
<li><strong>wait(long):</strong> 超时等待一段时间,单位是毫秒,若超时没有被唤醒则返回</li>
<li><strong>wait(long, int):</strong> 单位是纳秒</li>
</ul>
<h1 id="wait-notify机制原理"><a href="#wait-notify机制原理" class="headerlink" title="wait/notify机制原理"></a>wait/notify机制原理</h1><h2 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h2><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_wait%E3%80%81notify%E6%9C%BA%E5%88%B6_1.png" alt="image"></p>
<ul>
<li><strong>新建:</strong> 新创建的线程对象</li>
<li><strong>可运行:</strong> 线程创建后,其start()方法被调用,位于可运行线程池中,等待获取cpu使用权</li>
<li><strong>运行:</strong> 可运行状态的线程获取了cpu时间片,执行代码</li>
<li><p><strong>阻塞:</strong> 线程因为某种原因放弃了cpu使用权,直到线程进入可运行状态</p>
<ul>
<li><strong>等待阻塞:</strong> 执行了waitt()方法, JVM将该线程放入等待队列中</li>
<li><strong>同步阻塞:</strong> 获取对象锁失败, JVM将该线程放入锁池(lock pool)中</li>
<li><strong>其他阻塞:</strong> 执行了sleep()方法,或者发出了I/O请求, JVM将该线程置为阻塞状态,当sleep()状态超时或者I/O处理完毕线程重新转入可运行状态</li>
</ul>
</li>
<li><p><strong>死亡:</strong> 线程的方法执行结束或者发生异常</p>
</li>
</ul>
<h2 id="wait-notify流程"><a href="#wait-notify流程" class="headerlink" title="wait/notify流程"></a>wait/notify流程</h2><ul>
<li>线程A获取对象锁并且进入同步代码块执行锁对象的wait()方法(立即释放锁),通知锁监听器,释放锁并且进入等待队列</li>
<li>线程B获取对象锁并且进入同步代码块执行锁对象的notify/notifyAll方法,告诉锁监听器,通知该对象锁的等待队列 <strong>(执行notify/notifyAll方法并不立即释放锁,只有退出同步代码块才释放对象锁)</strong></li>
<li>线程A得到锁监听器的通知,移出等待队列变成可运行状态,并且尝试获取锁执行代码</li>
</ul>
<h2 id="wait-notify与synchronized"><a href="#wait-notify与synchronized" class="headerlink" title="wait/notify与synchronized"></a>wait/notify与synchronized</h2><p>执行wait/notify必须要加synchronized锁,因为synchronized代码块生成的字节码中包含<strong>monitorenter</strong>与<strong>monitorexit</strong>指令。</p>
<p>monitorenter指令可以获取对象的monitor,而wait()方法的底层实现依赖于该对象的monitor,即如果在synchronized代码中执行,必定获取到了对象的monitor。</p>
<h2 id="wait-notify与cpu资源"><a href="#wait-notify与cpu资源" class="headerlink" title="wait/notify与cpu资源"></a>wait/notify与cpu资源</h2><p>wait/nofity是通过JVM里的<strong>park/unpark</strong>机制来实现的,在Linux下这种机制又是通过<br><strong>pthread_cond_wait/pthread_cond_signal</strong> 来实现的，因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/非对称加密以及RSA加密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/非对称加密以及RSA加密/" itemprop="url">非对称加密以及RSA加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T01:36:37+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密需要一对密钥,即公钥和私钥。如果使用公钥加密,则只能用对应私钥才能解密;而如果使用私钥加密,则只能使用对应公钥才能解密。</p>
<p>非对称加密主要是为了解决对称加密的<strong>密钥传输</strong>与<strong>密钥管理</strong>问题。</p>
<h2 id="非对称加密的工作方式"><a href="#非对称加密的工作方式" class="headerlink" title="非对称加密的工作方式"></a>非对称加密的工作方式</h2><p>客户端向服务端发送数据流程:</p>
<ul>
<li>服务端生成公钥和私钥</li>
<li>服务端发送公钥给客户端</li>
<li>客户端通过公钥加密数据</li>
<li>客户端发送密文给服务端</li>
<li>服务端通过私钥解密密文</li>
</ul>
<p>公钥和私钥都可以用来加密数据。</p>
<h2 id="非对称加密的优点"><a href="#非对称加密的优点" class="headerlink" title="非对称加密的优点"></a>非对称加密的优点</h2><ul>
<li>解决密钥传输问题</li>
<li>解决密钥管理问题</li>
</ul>
<h2 id="非对称加密的缺点"><a href="#非对称加密的缺点" class="headerlink" title="非对称加密的缺点"></a>非对称加密的缺点</h2><ul>
<li>运算量大</li>
<li>速度慢</li>
<li>适合少量数据加密长</li>
</ul>
<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><p>RSA是非对称加密算法的一种,为了保证加密的安全性,RSA密钥的长度一般都是1024位或者2048位,使得RSA加密的计算量大、速度慢。</p>
<h2 id="RSA加密原理"><a href="#RSA加密原理" class="headerlink" title="RSA加密原理"></a>RSA加密原理</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA加密原理(一)</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA加密原理(二)</a></p>
<h2 id="RSA注意事项"><a href="#RSA注意事项" class="headerlink" title="RSA注意事项"></a>RSA注意事项</h2><p>实际开发中,一般采用RSA+ASE相结合的方式。即使用AES加密数据,使用RSA加密AES的密钥。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/对称加密以及AES加密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/对称加密以及AES加密/" itemprop="url">对称加密以及AES加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T19:37:19+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密就是加密和解密使用同一个密钥的加密算法。</p>
<h2 id="对称加密的工作方式"><a href="#对称加密的工作方式" class="headerlink" title="对称加密的工作方式"></a>对称加密的工作方式</h2><ul>
<li>使用密钥加密明文数据</li>
<li>发送密文</li>
<li>收到密文</li>
<li>使用同一套密钥解密密文</li>
</ul>
<h2 id="对称加密的优点"><a href="#对称加密的优点" class="headerlink" title="对称加密的优点"></a>对称加密的优点</h2><ul>
<li>计算量小</li>
<li>速度快</li>
<li>适合大量数据加密</li>
</ul>
<h2 id="对称加密的缺点"><a href="#对称加密的缺点" class="headerlink" title="对称加密的缺点"></a>对称加密的缺点</h2><h3 id="密钥传输问题"><a href="#密钥传输问题" class="headerlink" title="密钥传输问题"></a>密钥传输问题</h3><p>由于对称加密使用同一个密钥,所以算法的安全性不仅仅取决于加密算法,更取决于密钥能否安全保管。</p>
<p>实际开发通常是客户端向服务端请求对称加密的密钥,密钥通过非对称加密后再传输。</p>
<h3 id="密钥管理问题"><a href="#密钥管理问题" class="headerlink" title="密钥管理问题"></a>密钥管理问题</h3><p>随着用户的增多,密钥的数量也随着膨胀。</p>
<h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h1><p>AES(Advanced Encryption Standard)是用来替代之前的DES加密算法而出现的。</p>
<p>AES加密算法使用分组密码体制,每个分组数据的长度为128位16个字节,密钥长度可以是128位16个字节、192位或者256位,一共有四种加密模式,我们通常采用需要初始向量IV的CBC模式,初始向量的长度为128位16个字节。</p>
<h2 id="AES的加密原理"><a href="#AES的加密原理" class="headerlink" title="AES的加密原理"></a>AES的加密原理</h2><h3 id="分组密码体制"><a href="#分组密码体制" class="headerlink" title="分组密码体制"></a>分组密码体制</h3><p>AES采用分组密码体制,将明文分段,每段长度为128位16字节。如果长度不够16字节,则要通过Padding将数据填满16字节,然后分别的每段数据加密,最后拼接成为密文。</p>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>Padding用来填充不满16字节的分组数据,有三种不同的填充模式。</p>
<ul>
<li><strong>PKCS5</strong>: 缺少n的字节,就在末尾填充n字节的n</li>
<li><strong>PKCS7</strong>: 末尾填充0</li>
<li><strong>NOPADDING</strong>: 发送方保证不需要填充</li>
</ul>
<p>解密需要使用和加密端相同的Padding,通常采用PKCS7 Padding。</p>
<h3 id="初始向量IV"><a href="#初始向量IV" class="headerlink" title="初始向量IV"></a>初始向量IV</h3><p>初始向量是为了使加密更加安全可靠,长度规定为128位16字节,初始向量来源为随机生成。</p>
<h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥的长度可以为128位16字节、192位或者256位,位数越高强度越大,但是效率更低。</p>
<p>通常采用128位16字节的密钥,密钥来源为随机生成。</p>
<h3 id="四种加密模式"><a href="#四种加密模式" class="headerlink" title="四种加密模式"></a>四种加密模式</h3><p>四种加密模式分别为ECB(电子密码本模式)、CBC(密码分组链接模式)、CFB以及OFB模式。</p>
<h2 id="AES的加密流程"><a href="#AES的加密流程" class="headerlink" title="AES的加密流程"></a>AES的加密流程</h2><h3 id="ECB-电子密码本模式"><a href="#ECB-电子密码本模式" class="headerlink" title="ECB(电子密码本模式)"></a>ECB(电子密码本模式)</h3><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8AAES%E5%8A%A0%E5%AF%86_1.png.png" alt="image"></p>
<p>ECB是最基本的加密模式,相同的明文块会被加密成相同的密文块,更容易破解,不安全,因为很少使用。</p>
<h3 id="CBC-密码分组链接模式"><a href="#CBC-密码分组链接模式" class="headerlink" title="CBC(密码分组链接模式)"></a>CBC(密码分组链接模式)</h3><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8AAES%E5%8A%A0%E5%AF%86_2.png" alt="image"></p>
<ul>
<li>AES将明文按128位16字节分割,如果最后一块不够则通过Padding填充</li>
<li>然后将明文块0与初始向量IV进行异或操作,再用密钥加密,得到密文块0,同时密文块0作为明文块1的加密向量</li>
<li>然后明文块1与密文块0进行异或,再用密钥加密得到密文块1</li>
<li>最后将所有密文块拼接得到密文</li>
</ul>
<h2 id="AES的注意事项"><a href="#AES的注意事项" class="headerlink" title="AES的注意事项"></a>AES的注意事项</h2><ul>
<li>服务端与客户端使用相同的<strong>密钥</strong></li>
<li>服务端与客户端使用相同的<strong>初始向量IV</strong></li>
<li>服务端与客户端使用相同的<strong>加密模式</strong> </li>
<li>服务端与客户端使用相同的<strong>Padding</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/Hash算法以及MD5/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Hash算法以及MD5/" itemprop="url">Hash算法以及MD5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T18:32:37+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MD5(Message Digest Algorithm MD5)是一种Hash算法,严格来说并不是一种加密算法,但是可以达到加密的效果。</p>
<h1 id="MD5算法的优点"><a href="#MD5算法的优点" class="headerlink" title="MD5算法的优点"></a>MD5算法的优点</h1><h2 id="容易计算以及不可逆"><a href="#容易计算以及不可逆" class="headerlink" title="容易计算以及不可逆"></a>容易计算以及不可逆</h2><ul>
<li>主流编程语言基本都支持MD5算法的实现</li>
<li>MD5是一个不可逆的算法,无法通过MD5值逆推原文</li>
</ul>
<h2 id="压缩性"><a href="#压缩性" class="headerlink" title="压缩性"></a>压缩性</h2><ul>
<li>任意长度的数据的MD5值都是一个32位长度的十六进制字符串,区分大小写</li>
</ul>
<h2 id="抗修改性"><a href="#抗修改性" class="headerlink" title="抗修改性"></a>抗修改性</h2><ul>
<li>原文即便是微小的修改,MD5也会有巨大的变动</li>
</ul>
<h2 id="抗碰撞性"><a href="#抗碰撞性" class="headerlink" title="抗碰撞性"></a>抗碰撞性</h2><ul>
<li>MD5共有2的128次方种可能性,实际中找到两个相同的MD5值是非常困难的</li>
</ul>
<h1 id="MD5算法的缺点"><a href="#MD5算法的缺点" class="headerlink" title="MD5算法的缺点"></a>MD5算法的缺点</h1><ul>
<li>安全性</li>
</ul>
<h1 id="MD5算法的场景"><a href="#MD5算法的场景" class="headerlink" title="MD5算法的场景"></a>MD5算法的场景</h1><h2 id="用户信息存储"><a href="#用户信息存储" class="headerlink" title="用户信息存储"></a>用户信息存储</h2><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>为了预防数据库泄露带来的严重后果,数据库中不应存放用户私密数据的明文。</p>
<h3 id="MD5的弊端-彩虹表"><a href="#MD5的弊端-彩虹表" class="headerlink" title="MD5的弊端(彩虹表)"></a>MD5的弊端(彩虹表)</h3><p>彩虹表是一个庞大的数据库,存放着常用的密码以及对应的MD5、SHA-X等Hash值，如果密码较为简单就有可能被彩虹表破译掉。</p>
<h3 id="正确的加密方法-salt"><a href="#正确的加密方法-salt" class="headerlink" title="正确的加密方法(salt)"></a>正确的加密方法(salt)</h3><p>加盐:在密码的任意位置插入一些特殊的字符串(salt)的过程。</p>
<p>加盐是为了增强密码的复杂性,从而降低了密码被彩虹表破译的概率。</p>
<p>加盐的要求:</p>
<ul>
<li>每个用户的salt最好具有唯一性</li>
<li>salt最好由服务器为每个用户随机生成</li>
<li>撒盐的方法最好复杂一点</li>
</ul>
<h3 id="实际开发流程"><a href="#实际开发流程" class="headerlink" title="实际开发流程"></a>实际开发流程</h3><p>服务端进行加盐操作:</p>
<ul>
<li>客户端对password进行MD5</li>
<li>通过接口传递加密后的数据</li>
<li>服务端MD5(客户端传递的加密数据 + salt)</li>
<li>服务端保存数据</li>
</ul>
<h2 id="生成数字签名"><a href="#生成数字签名" class="headerlink" title="生成数字签名"></a>生成数字签名</h2><p>微信支付通过MD5生成数字签名</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/常见加密算法概述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/常见加密算法概述/" itemprop="url">常见加密算法概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T17:52:47+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常见的加密算法可以分为三类,即对称加密算法、非对称加密算法以及hash算法。</p>
<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密指加密和解密使用相同密钥的加密。</p>
<p>对称性加密算法的安全性取决于加密密钥的保存情况,但是密钥会随着用户的增加而膨胀。</p>
<p><strong>常见的对称加密算法:</strong> AES、DES、3DES、IDEA等。</p>
<h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密指加密和解密使用不同密钥的加密算法,也称为公私钥加密。</p>
<p>双方交换数据,首先使用对方的公钥进行加密,对方可使用自己的私钥进行解密。</p>
<p>由于公钥是公开的,即用户只需要保存私钥即可,简化了密钥的分发,但是非对称加密的效率与对称性加密相比十分低下。</p>
<p><strong>常见的非对称加密算法:</strong> RSA、ECC(移动设备)、DSA(数字签名)等。</p>
<h1 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h1><p>Hash算法是一种单向不可逆的算法,因此常被用在不可还原的密码存储、信息完整性校验等。</p>
<p><strong>常见的Hash算法:</strong> MD5、SHA、SHA-1等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/Https详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Https详解/" itemprop="url">Https详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T15:36:28+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTPS连接过程"><a href="#HTTPS连接过程" class="headerlink" title="HTTPS连接过程"></a>HTTPS连接过程</h2><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_https_1.png" alt="image"></p>
<h2 id="HTTPS的详细连接流程"><a href="#HTTPS的详细连接流程" class="headerlink" title="HTTPS的详细连接流程"></a>HTTPS的详细连接流程</h2><p><strong>1.客户端向服务端发送https请求</strong></p>
<p><strong>2.服务器端生成公钥与私钥</strong></p>
<p><strong>3.服务器端向客户端返回公钥</strong></p>
<p>公钥包含证书的颁发机构、过期时间等</p>
<p><strong>4.客户端验证公钥</strong></p>
<p>客户端验证公钥的有效性,如果验证失败则抛出异常;否则生成一个随机值作为密钥,并且使用服务端的公钥加密密钥</p>
<p><strong>5.客户端向服务端发送密钥</strong></p>
<p><strong>6.服务端获取密钥,对内容加密</strong></p>
<p>服务端收到加密后的密钥,通过私钥解密得到客户端的密钥,并且使用密钥将内容进行对称加密</p>
<p><strong>7.服务端向客户端传输密文</strong></p>
<p><strong>8.客户端解密密文</strong></p>
<p>客户端通过之前生成的密钥解密密文,得到内容</p>
<h1 id="中间人劫持攻击"><a href="#中间人劫持攻击" class="headerlink" title="中间人劫持攻击"></a>中间人劫持攻击</h1><h2 id="中间人劫持攻击过程"><a href="#中间人劫持攻击过程" class="headerlink" title="中间人劫持攻击过程"></a>中间人劫持攻击过程</h2><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_https_2.png" alt="image"></p>
<h2 id="中间人攻击的预防"><a href="#中间人攻击的预防" class="headerlink" title="中间人攻击的预防"></a>中间人攻击的预防</h2><p>中间人劫持攻击的前提是客户端信任中间人的证书,而造成这种情况一般是服务端没有对服务端证书及域名作校验或者校验不完整。</p>
<ol>
<li>客户端预埋证书的方式锁死证书,只有当客户端证书和服务端证书完全一致才允许通信(证书过期需要强制更新或者要求下载证书)</li>
<li>客户端校验域名、证书有效期、证书关键信息以及证书链</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Dawn</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/delaube" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="lu923418335@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawn</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
