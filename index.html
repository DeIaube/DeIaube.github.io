<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Dawn">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dawn">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dawn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Dawn</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dawn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/深入理解Java类加载/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/深入理解Java类加载/" itemprop="url">深入理解Java类加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T23:19:50+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>详细讲解一下类加载的过程，也就是加载，验证，准备，解析和初始化这5个阶段所执行的具体动作。</p>
<p>##加载</p>
<p>加载阶段，虚拟机要完成三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>讲这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>其中二进制字节流可以从ZIP包中获取，从网络获取，运行时计算生成，由其他文件生成，由数据库生成等。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符号当前虚拟机的要求并且不会危害虚拟机的安全。</p>
<p>验证分为以下四步：文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<ol>
<li><p>文件格式验证：<br> 保证输入的字节流能正确的解析并且存储于方法区内，格式上符号描述一个Java类型信息的要求。此阶段验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流彩绘进入内存的方法区进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会直接操作字节流。</p>
</li>
<li><p>元数据验证：<br> 对类的原数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p>
</li>
<li><p>字节码验证：<br> 整个验证最复杂的一个阶段。通过数据流和控制流分析，确定程序语义是合法的，是符合逻辑的。  </p>
</li>
<li><p>符号引用验证：<br> 发生在虚拟机将符号引用转化为直接饮用的时候，整个动作可以看做是对类自身以外的信息进行匹配性校验。</p>
</li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段正式为类分配内存并且设置变量的初值，这些变量使用的内存将在方法区中进行分配。这时候进行内存分配的仅包括类变量而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能在使用时无歧义地定位到目标即可，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。有符号引用，对象不一定在内存中存在。</li>
<li>直接引用：直接引用可以是直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。如果有了直接引用那么对象一定在内存中存在。</li>
</ul>
<p>解析动作主要针对于类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限符7类符号引用</p>
<h3 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h3><p>当前代码所处的类为D，要将一个未解析过的符号引用N解析为一个类或者接口C的直接引用，分三个步骤：</p>
<ol>
<li>如果C不是一个数组类型，那么虚拟机会将代表它的全限定名传递给D的类加载器去加载这个类C</li>
<li>如果C是一个数组，而且数组的元素类型为对象，也就是N的描述符回事类似[Ljava/lang/Integer的形式，会按照第一点的规则加载数组元素类型。接着由虚拟机生成一个代表此元素维度和元素的数组对象</li>
<li>确认D是否对C的访问权限</li>
</ol>
<h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><p>字段所属的类或者接口用C标示，解析字段分四个步骤：</p>
<ol>
<li>如果C本省包含了简单名称和字段描述符都匹配的字段，则查找结束</li>
<li>如果C中实现了接口，会按照继承关系递归搜索，如果找到包含了简单名称和字段描述符都匹配的字段，则查找结束</li>
<li>如果C不是java.lang.Object,则按照继承关系从下往上递归搜索其父类，如果找到包含了简单名称和字段描述符都匹配的字段，则查找结束</li>
<li>否则，则查找失败</li>
</ol>
<h3 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h3><p>类方法解析分为五步：</p>
<ol>
<li>类方法和接口方法引用的常量类型定义是分开的，如果在类方法中发现class_index项中索引的C是个接口，那么就直接抛出异常</li>
<li>在类C中查找是否有简单名称和描述符都与目标相匹配的方法，若有则查找结束</li>
<li>在类C的父类中递归查找，若有简单名称和描述符都与目标相匹配的方法则查找结束</li>
<li>在类C的接口列表以及他们的父接口中查找，若有简单名称和描述符都与目标相匹配的方法则查找结束</li>
<li>否则查找失败</li>
</ol>
<h3 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h3><p>接口方法解析分为四步：</p>
<ol>
<li>如果发现class_index中的索引是个类而不是接口，那么直接抛出异常</li>
<li>否则在接口C中查找是否有简单名称和描述符都相匹配的方法，如果有则查找结束</li>
<li>否则在接口C的父接口中递归查找，知道java.lang.Object为止，看否有简单名称和描述符都相匹配的方法，如果有则查找结束</li>
<li>否则查找失败</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化时类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码（字节码）。</p>
<p>初始化阶段是执行类构造器<clinit>()方法的过程，以下是<clinit>()方法的特点：</clinit></clinit></p>
<ul>
<li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，其顺序由语句在源文件中出现的顺序决定</clinit></li>
<li><clinit>()方法与类的狗构造器不同，他不需要显式的调用父类构造器，虚拟机保证子类的<clinit>()方法执行之前父类的<clinit>()方法已经执行完毕</clinit></clinit></clinit></li>
<li>由于父类的<clinit>()方法先执行，所以父类的静态语句要优先于子类变量赋值操作</clinit></li>
<li>如果一个类中，没有静态语句块，也没有对变量的赋值操作，那么编译器可以不生成<clinit>()方法</clinit></li>
<li>接口中不能使用静态语句块，但是可以有变脸初始化的赋值操作</li>
<li>虚拟机保证一个类的<clinit>()方法在多线程环境下被正确的加锁，同步，如果多个线程同事去初始化一个类，那么只有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞知道活动线程<clinit>()方法执行完毕</clinit></clinit></clinit></li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器可以实现通过一个类的全限定名来获取描述此类的二进制字节流。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在Java虚拟机中的唯一性。</p>
<p>虽然是同一个类，但是如果通过不同的类加载器加载，做对象所属类型检查时仍然是false。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>大部分Java程序都会使用到以下3中系统提供的类加载器：</p>
<ol>
<li>启动类加载器(Booststrap ClassLoader)</li>
<li>扩展类加载器(Extensioin ClassLoader)</li>
<li>应用程序类加载器(Application ClassLoader)</li>
</ol>
<p>这些加载器的关系如下所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD_1.png" alt=""></p>
<p>双亲委派模型的工作过程是：当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此。</p>
<p>使用双亲委派模型的好处就是java类随着他的类加载器一起具备了一种带有优先级的层次关系。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/高效并发之Java内存模型与线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/高效并发之Java内存模型与线程/" itemprop="url">高效并发之Java内存模型与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T22:16:55+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java内存模型和线程"><a href="#Java内存模型和线程" class="headerlink" title="Java内存模型和线程"></a>Java内存模型和线程</h1><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>由于处理器和主存速度差异巨大，所以产生了高速缓存作为两者其中的缓冲。</p>
<p>高速缓存的出现解决了速度不匹配的问题，不过也带来了新的问题：缓存一致性。在多处理器系统中每个处理器都有自己的高速缓存，而他们却共享同一主存。运算时可能导致不同处理器缓存数据不一致，那同步回主存的缓存数据以谁为准呢？</p>
<p>为了解决缓存一致性问题，每个处理器访问缓存都遵循一些协议。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_1.jpg" alt="image"></p>
<p>为了充分利用处理器内部的运算单元尽量被利用，处理器可能会对输入代码进行乱序执行优化。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java虚拟机试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异。</p>
<h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>Java内存模型规定了所有变量都存储在主内存，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。</p>
<p>线程对变量的所有操作（读取，赋值等）操作都必须在工作内存中进行，而不能直接读写主内存的变量，线程间变量值的传递均需要通过主内存来完成，线程，主内存，工作内存三者的交互关系如图所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_2.jpg" alt="image"></p>
<p>此处的变量包括实例字段，静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java内存模型中定义了以下8中操作完成一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节。</p>
<ol>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占的状态</li>
<li>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他变量锁定</li>
<li>read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便以后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时会执行这个操作</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行此操作</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便以后的write操作使用</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ol>
<p>如果要把一个值从主内存复制到工作内存，那就要顺序的执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序执行store和write操作。然而顺序执行并不是连续执行。</p>
<p>Java内存模型还规定了以下规则：</p>
<ul>
<li>不允许read和load,store和write操作之一单独出现，即不允许出现一个变量从主内存读取了但是工作内存不接受，或者从工作内存发起了回写但是主内存不接受的情况出现</li>
<li>不允许一个线程丢弃他最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主存</li>
<li>不允许一个线程无原因地（没有发生任何assign操作）把数据从线程的工作内存同步回主内存</li>
<li>一个新的变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但是lock操作可以被同一条线程重复执行多次，同时只有执行相同次数的unlock操作，变量才会被解锁</li>
<li>如果对一个变量执行lock操作，那么会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量未被lock，那么不允许对他执行unlock</li>
<li>对一个变量执行unlock之前，必须把次变量同步回主内存</li>
</ul>
<h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>当一个变量定义为volatile之后，它具备两个特性：</p>
<ol>
<li>保证此变量对所有线程的可见性，即单轨条线程修改了这个变量的值，新值对于其他线程来说是立即可知的</li>
<li>禁止指令重排序优化</li>
</ol>
<p>假设T表示一个线程，V和W分别代表两个volatile变量，那么有如下规则：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_3.jpg" alt="image"></p>
<h3 id="long和double型变量的特殊规则"><a href="#long和double型变量的特殊规则" class="headerlink" title="long和double型变量的特殊规则"></a>long和double型变量的特殊规则</h3><p>Java内存模型要求8个基本操作具有原子性。</p>
<p>但对于64位数据（long和double），模型中定义了一条相对宽松的规定：允许虚拟机将没有volatile修饰的64位数据的读写操作划分为两次32位操作。</p>
<p>这就是long和double的非原子性协定。</p>
<h3 id="原子性，可见性和有序性"><a href="#原子性，可见性和有序性" class="headerlink" title="原子性，可见性和有序性"></a>原子性，可见性和有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性，可见性和有序性这3个特征来建立的。</p>
<p>原子性：基本数据类型的访问读写是具备原子性的（double和long例外）。</p>
<p>可见性：指一个线程修改了共享变量的值，其他线程能够立即得知这个修改。能实现可见性的有volatile，synchronized和final。同步快的可见性是由对一个变量执行unlock之前，必须先把此变量同步回主内存。</p>
<p>有序性：如果在本线程内观察，所有的操作都是有序的，如果在一个线程观察另一个线程，所有的操作都是无序的。前半句指的是线程内表现为串行执行，后半句指的是指令重排序现象和工作内存与主内存同步延迟。能实现有序性的有volatile和synchronized，synchronized是通过一个变量在同一时刻只允许一条线程对其进行lock操作这条规则获得的。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生原则事发生在Java内存模型中定义的两项操作中的偏序关系，如果操作A现行发生于操作B，操作A产生的影响就能被操作B观察到。</p>
<p>下面是Java内存模型下一些天然的先行发生关系：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_4.jpg" alt="image"></p>
<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程可以共享进程资源，又可以独立调度（线程是CPU调度的基本单位）。</p>
<p>线程的实现主要有三种方式：使用内核实现，使用用户线程实现，使用用户线程加轻量级进程混合实现。</p>
<h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><p>这种线程由内核来完成线程切换，每个内核线程可视为内核的一个分身，这样操作系统就可以同时处理多件事情，支持多线程的内核就叫做多线程内核。</p>
<p>程序一般不直接使用内核线程而使用轻量级进程（LWP就是线程）。轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_5.jpg" alt="image"></p>
<ul>
<li><p>优点：即便有一个轻量级进程阻塞了也不影响整个进程执行</p>
</li>
<li><p>缺点：系统调用代价高，需要在用户态和内核态之间来回切换</p>
</li>
</ul>
<h3 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h3><p>广义上来讲，一个线程只要不是内核线程就可以被认为是用户线程（UT）。</p>
<p>狭义上来讲，用户线程是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的各种操作建立在用户的线程库上，如果程序得当，这种线程不需要切换到内核态。</p>
<p>部分高性能数据库中的多线程就是使用用户线程实现的，这种进程与用户县城之间1：N的关系称为一对多的线程模型。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_6.jpg" alt="image"></p>
<ul>
<li><p>优点：不需要系统内核支援</p>
</li>
<li><p>缺点：不需要系统内核支援</p>
</li>
</ul>
<h3 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h3><p>这种实现方式下，即存在用户线程，也存在轻量级进程。 </p>
<p>用户线程的各项操作依然廉价，而且可以使用内核提供的线程调度更能以及处理器映射。</p>
<p>这种模式中，用户线程与轻量级进程的数量比是不定的，为N:M的关系。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_7.jpg" alt="image"></p>
<h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>在目前的JDK版本中，操作系统支持什么怎样的线程模型，很大程度上了决定了Java虚拟机中的线程是怎样映射的。</p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度指的是系统为线程分配处理器使用权的过程，主要调度分两种，分别是协同式线程调度和抢占式线程调度。</p>
<p>协同式调度：线程的执行时间由线程自己决定，一个线程将自己的工作执行完毕后会主动通知系统切换到另外一个线程上。</p>
<p>抢占式调度：线程的执行时间由系统决定。</p>
<p>我们可以设置线程优先级来建议系统分配线程的执行时间，不过由于线程调度取决于具体的操作系统，所以并不一定奏效。</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>Java定义了5种线程状态：</p>
<ol>
<li>新建（New）：创建后尚未启动的线程处于这种状态</li>
<li>运行（Runble）：Runble包括了操作系统状态中的Running和Ready，这个状态下的线程可能正在运行或者正在等待CPU分配时间片</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，他们要等待被其他线程显示的唤醒，以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.parl()方法</li>
</ul>
</li>
<li>限期等待：处于这种状态的线程也不会被分配CPU执行时间，不过无需其他线程显示唤醒，在一段时间之后他们有系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>
<li>Thread.sleep()方法</li>
<li>设置了Timeout参数的Object.wait()方法</li>
<li>设置了Timeout参数的Thread.join()方法</li>
<li>LockSupport.packNanos()方法</li>
<li>LockSupport.packUntil()方法</li>
</ul>
</li>
<li>阻塞：线程被阻塞了，等待一个排它锁，这个时间将在另外一个线程放弃这个锁的时候发生</li>
<li>结束：已终止线程的线程状态，线程已经结束执行</li>
</ol>
<p>上述各种状态的相互转换如下图所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_8.jpg" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/高效并发之Java线程安全与锁优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/高效并发之Java线程安全与锁优化/" itemprop="url">高效并发之Java线程安全与锁优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T22:10:19+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的记过，那么这个对象时线程安全的。</p>
<h2 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h2><p>按照安全程度由强至弱来排序，我们可以将Java语言中的各种共享的数据分为以下5类：不可变，绝对线程安全，相对线程安全，线程兼容和线程对立。</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>不可变的对象一定时线程安全的。</p>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>一个类要达到绝对线程安全，通常需要付出很大的，甚至不切实际的代价。在Java API中标注自己是线程安全的类，大多都不是绝对的线程安全。</p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>相对的线程安全就是我们通常意义上所讲的线程安全，需要保证对这个对象单独的操作是线程安全的，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>对象本身不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。</p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。而互斥是实现同步的一种手段，主要实现方式有临界区，互斥量，信号量。</p>
<p>在Java中使用synchronized关键字实现互斥，其经过编译后，在代码块分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明锁定和解锁的对象。如果没有明确指定那就根据synchronized修饰的是实例方法还是类方法，去取对象实例或者Class对象作为锁对象。</p>
<p>执行monitorenter指令，首先尝试获取锁，如果这个对象没有被锁定或者已经获取到了锁，就将计数器+1。相应的monitorexit会将锁计数器-1，其值为0时释放锁。</p>
<p>synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的问题。</p>
<p>如果阻塞或者唤醒一个进程，需要用户态与内核态的转换，所以synchronized是一个非常重量级的操作。</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>非阻塞同步就是基于冲突检测的乐观并发策略。</p>
<p>就是进行先行操作，如果没有其他线程争用共享数据，那么操作就成功了。如果有争用，那就采取其他补偿措施（不断重试，知道成功为止）。</p>
<p>我们需要操作和冲突检测这两个步骤具有原子性，只能依靠硬件完成。</p>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h2><p>自旋锁：如果物理机器有一个以上的处理器，能让连个或者两个以上的线程同时并且并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间。为了让线程等待，我们只需要让线程执行一个忙循环（自旋）。</p>
<p>自适应自旋：自旋的时间由上一次在同一个锁上的自选时间以及锁的拥有者的状态来决定。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指在即时编译器运行时，对一些在代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除，判定依据来源于逃逸分析的数据支持。</p>
<p>如果一段代码中，堆上的所有数据都不会逃逸出去被其他线程访问，那么就可以把他们当做栈上数据，同步加锁也就无需进行。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列操作都是对一个对象反复加锁解锁，例如在循环体中进行加锁解锁操作，会导致不必要的性能损耗。</p>
<p>如果虚拟机检测到这种情况，会将加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>HotSpot虚拟机的对象头分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码，GC分带年龄等，这部分数据是实现轻量级锁和偏向锁的关键，官方称他们为Mark Word。另一部分用于存储指向方法区对象类型数据的指针。</p>
<p>Mark Word会根据对象的状态复用自己的存储空间，存储内容如下所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E4%B9%8BJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96_1.png" alt=""></p>
<p>在代码进入同步块的时候，如果同步对象没有被锁定（锁标志位为01状态），虚拟机将会首先在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝.</p>
<p>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。</p>
<p>如果成功，那么这个线程就拥有了这个对象的锁，并且对象的Mark Word的锁标志位将转变为00，标示此对象处于轻量级锁定状态。</p>
<p>如果失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁的标志变为10，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。</p>
<p>轻量级锁能提升程序同步性能的依据是对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但是如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作。</p>
<p>因此在有竞争的情况下， 轻量级锁比传统的重量级锁更慢。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁的目的是消除数据在无竞争情况下的同步原语。</p>
<p>如果说轻量级锁是在无竞争条件下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，而且连CAS都不需要做。</p>
<p>偏向锁中的锁偏向于第一个获得他的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。</p>
<p>假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将对象头中的标志位设置为01，即偏向模式。同时使用CAS操作吧获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入到这个锁相关的同步块的时候都不需要同步。当有另外一个线程尝试去获取这个锁时，偏向模式就宣告结束。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/Java自动内存管理机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/Java自动内存管理机制/" itemprop="url">Java自动内存管理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T21:58:01+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块比较小的内存空间。他可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令。</p>
<p>由于一个处理器只会处理一条线程中的指令，所以每个线程都需要一个独立的程序计数器。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的，生命周期与线程相同。</p>
<p>Java方法在执行的同事都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表存放了编译器可知的各种基本数据类型以及对象引用和returnAddress类型。</p>
<p>long和double占用两个Slot单位，在方法运行期间不会改变局部变量表的大小。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈为Native方法服务，具体的虚拟机可以自由的实现它。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>堆是Java虚拟机所管理的内存中最大的一块，是被所有县城共享的一块内存区域，几乎所有的对象都在堆上面分配内存。</p>
<p>堆是垃圾收集器管理的主要区域，可分为新生代和老年代。</p>
<p>堆可以处于物理上不连续的内存空间，只要逻辑连续即可。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区和堆一样都是各个线程共享的内存区域，存储被虚拟机加在的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p>
<p>Java虚拟机规范对方法区的限制比较宽松，除了和Java堆一样可以不需要连续的内存和可以选择固定大小或者可以扩展外，还可以选择不实现垃圾收集。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</p>
<h2 id="虚拟机对象探秘"><a href="#虚拟机对象探秘" class="headerlink" title="虚拟机对象探秘"></a>虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol>
<li>虚拟机遇到一个new指令时，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载解析和初始化过，否者要执行响应的类加载过程</li>
<li>为新生对象分配内存。即在堆中划分出一块确定大小的内存</li>
<li>将分配到的内存空间初始化为零（不包括对象头）</li>
<li>对对象进行必要的设置，例如放在对象头中的类的元数据，对象的哈希码，对象个GC分带年龄等信息</li>
<li>执行<init>方法</init></li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为3块区域：对象头，实例数据，对齐填充。</p>
<p>对象头包括两部分信息：</p>
<ol>
<li><p>存储对象自身的运行时数据，如哈希码，GC分带年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等</p>
</li>
<li><p>类型指针。即对象指向它的类元素的指针，虚拟机通过这个指针来确定这个对象是哪儿个类的实例</p>
</li>
<li><p>如果对象是数组的话，那么在对象头中记录着数组长度</p>
</li>
</ol>
<p>实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，无论是继承的还是子类中定义的。默认情况下相同宽度的字段会分配到一起。</p>
<p>对齐填充只是要求对象的大小是8字节的整数倍，当对象实例数据没有对齐时，需要对齐填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>目前主流的对象访问方式有使用句柄和直接指针两种。</p>
<ul>
<li><p>如果使用句柄，那么在堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6_1.png" alt=""></p>
</li>
<li><p>如果使用直接指针访问，那么堆对象的布局就要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。<br><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6_2.png" alt=""></p>
</li>
</ul>
<p>使用句柄好处是拥有稳定的句柄地址，在对象被移动时只改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，节省了一次指针定位的时间开销。</p>
<h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死"></a>对象已死</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>为对象添加一个引用计数器，当一个地方引用它时计数器加一，当引用失效时，计数器减一。</p>
<p>引用计数法判定效率高但是无法解决相互循环引用的问题。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思路就是通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到一个GC Roots没有任何引用链相连，则认为此对象是不可用的。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在JDK 1.2 之后，Java扩充了引用的概念。</p>
<ul>
<li><p>强引用：普遍存在的引用，只要强引用还存在，垃圾回收期永远不会回收掉被引用的对象</p>
</li>
<li><p>软引用：描述一些有用但是非必须的对象。软引用引用的对象在将要发生内存溢出异常之前，将会把这些对象列入回收范围进行二次回收。如果这次回收仍然没有足够的内存，那么将会抛出内存溢出异常</p>
</li>
<li><p>弱引用：弱引用引用的对象只能生存到下一次垃圾收集之前</p>
</li>
<li><p>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获得一个对象实例。虚引用的唯一作用就是在这个对象被收集器回收时收到一个系统通知</p>
</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>如果一个对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么他会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果对象没有覆盖finalize()方法，或者finalize()方法已经被调用过，虚拟机将这两种情况视为没必要执行。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列中，并且在稍后由一个由虚拟机自动建立的，低优先级的Finalizer线程去执行。finalize()方法是对象逃脱死亡的最后一次机会。</p>
<p>任何一个对象的finalize()方法只会被系统调用一次，如果对象面临下一次回收，他的finalize()方法将不会被执行。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久带的垃圾回收主要是回收废弃常量和无用类。</p>
<ol>
<li>废弃常量：比如一个字符串在常量池但是当前系统中没有一个对象引用此字符串</li>
<li><p>无用类：</p>
<ul>
<li>该类所有实例被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的Class对象没有任何地方被引用，无法再任何地方通过反射访问该类的方法</li>
</ul>
</li>
</ol>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6_3.png" alt=""><br>缺点：</p>
<ul>
<li><p>标记和清除两个过程效率都不高</p>
</li>
<li><p>标记清除之后会产生大量不连续的内存碎片</p>
</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块用光了，那就将还存活着的对象复制到另外一块上面，然后将已经使用过的内存空间一次清理掉。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6_4.png" alt=""></p>
<p>缺点：使可用内存减少</p>
<p>现在商业虚拟机使用这种方法回收新生代，将内存分为较大的Eden和两块较小的Survivor空间，每次使用Eden和其中一块Surivor。</p>
<p>回收时将Eden和Survivor中还存活的对象一次性的复制到另一块Survivor空间上，然后清理掉Eden和刚才使用过的Survivor空间。默认Eden和Survivor的大小比例是8：1。</p>
<p>如果当Surivivor空间不够用时，需要依赖其他内存（老年代）进行分配担保。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>过程与标记-清除算法一样，但是后续步骤将所有存活对象向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6_5.png" alt=""></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存货周期的不同将内存分为几块，通常将堆分为新生代和老年代。</p>
<p>新生代每次垃圾收集都有大批对象死去，所以采用复制算法，老年代对象存活率高，所以采用标记-清除或者标记-整理算法。</p>
<h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>GC Roots的节点主要体现在全局性的引用和执行上下文中，如果要执行检查其中的引用必然要耗费大量时间，而且枚举根节点必然要发生GC停顿。</p>
<p>在虚拟机中使用叫OopMap的数据结构得知哪儿些地方存放着对象引用。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在虚拟机中只有在特定的位置记录了OopMap信息，这些位置称为安全点。</p>
<p>只有在安全点才能停顿下来进行GC。</p>
<p>使GC发生时所有县城跑到最近的安全点并且停顿下来有两种方法：</p>
<ul>
<li>抢先式中断：在GC时，首先把所有线程全部中断，如果发现有线程中断不在安全点上，就恢复线程，让他跑到安全点上。</li>
<li>主动式中断：设置一个标志，让各个线程去轮训这个标志，发现中断标志为真就让自己中断挂起。</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域是指在一端代码片段中，引用关系不会发生变化。在这个区域中任意地方GC都是安全的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/程序编译与代码优化之运行期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/程序编译与代码优化之运行期/" itemprop="url">程序编译与代码优化之运行期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T21:09:45+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，虚拟机会将这些代码翻译成本地平台相关的机器码，并且进行各种层次的优化，完成这个任务的编译器叫做即时编译器（JIT编译器）。</p>
<h2 id="HotSpot内的即时编译器"><a href="#HotSpot内的即时编译器" class="headerlink" title="HotSpot内的即时编译器"></a>HotSpot内的即时编译器</h2><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器可以省去编译的时间，立即执行。编译器可以将代码编译成本地代码，获得更高的执行效率。</p>
<p>解释器可以作为编译器激进优化的一个逃生门，让编译器根据概率选择一些大多数时候能提升运行素的的优化手段，如果假设不成立可以通过逆优化退回到解释状态据需执行。</p>
<h3 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h3><p>在运行阶段被即时编译器编译的热点代码有两类：</p>
<ol>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ol>
<p>这两种情况JIT编译器都会把整个方法作为编译对象。</p>
<p>判断一段代码是不是热点代码的行为成为热点探测，目前热点探测判定标准有两种：</p>
<ol>
<li>基于采样的热点探测：虚拟机会周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是热点方法。</li>
<li>基于计数器的热点探测：虚拟机会为每个方法甚至是代码块建立计数器，统计执行次数，如果超过某个阈值就认为他是热点方法。</li>
</ol>
<p>在HotSpot虚拟机中采用了第二种方法，为每个方法准备了两类计数器：方法调用计数器和回边计数器。</p>
<p>方法调用计数器其交互过程如下所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%9F_1.png" alt="image"></p>
<p>方法调用计数器统计的是一段时间内方法的执行频率。当超过一定时间限度此方法调用次数仍不足以让它提交给即时编译器编译，那么他的调用计数器就会较少一半。</p>
<p>回边计数器作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令成为回边。回边计数器的交互过程如下所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%9F_2.png" alt="image"></p>
<p>回边计数器统计的是方法循环执行的绝对次数，没有计数热度衰减的过程。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>后台编译分三个阶段：</p>
<ol>
<li>一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR），HIR使用静态单分配的形式来代表代码值，在此之前会完成如方法内联，常量传播等优化。</li>
<li>一个平台相关的后端从HIR中产生低级中间代码表示，自此之前完成如空值检查消除，范围检查消除等操作。</li>
<li>在平台相关的后端使用现行扫描算法在LIR上分配寄存器，并且在LIR上做窥孔优化，然后产生机器代码。</li>
</ol>
<h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>如果一个表达式E已经计算过了，而且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，字需要直接用前面计算过的表达式结果代替E就可以了。</p>
<h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0, foo.length)之内，拿在整个循环中就可以把数组的上下界消除，节约了多次的条件判定操作。</p>
<p>减少隐式开销的方法除了将这种数组边界检查优化尽可能提前到编译器完成之外，还有一种方法——隐式异常处理，java中空指针检查和算术异常检查都采用这种方法。</p>
<p>Java伪代码来表示虚拟机访问foo.value的过程示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(foo != null)&#123;</span><br><span class="line">    return foo.value;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    throw new NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用隐式优化后，虚拟机将上面的代码表示的访问过程变成下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    return foo.value;</span><br><span class="line">&#125;catch(segment_fault)&#123;</span><br><span class="line">    uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机会注册一个Segment Fault信号的异常处理器，当foo不为空时，对value的访问是不会额外消耗一次对foo判空的开销。若foo为空，必须转入到异常处理器中恢复并且抛出空指针异常，这个过程从用户态转入内核态处理然后再回到用户态，速度 非常慢。</p>
<p>如果foo极少为空的时候，优化是值得的。HotSpot虚拟机会根据运行期间收集到的Profile信息自动选择最优方案。</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>Java虚拟机设计团队为了解决虚方法内联问题引入了一个名为类型继承关系分析（CHA）的技术。</p>
<p>编译器在进行内联时，如果是非虚方法直接进行内联即可。</p>
<p>如果是虚方法，则向CHA查询此方法在当前程序下是否有多个版本可以选择，如果查询到只有一个版本可以进行内联，不过这种内联属于激进优化，需要预留一个逃生门，称为守护内联。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的继承关系发生变化的类，那么这个内链优化的代码就可以一直执行下去。如果加载了导致继承关系发生变化的新类，那就要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</p>
<p>如果CHA查询到多个版本的目标方法可供选择，则编译器会使用内联缓存来完成方法内联。它的工作原理是：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接受者的版本信息，而且每次进行方法调用时都比较接受者版本，如果以后进来的每次调用的方法接受者版本都是一样的，那么这个内联还可以一直用下去。如果发生了不一致的情况，就说明程序使用了虚方法的多态特性，这是会取消内敛，查找虚方法表进行方法分派。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ol>
<li>当一个对象在方法中被定义后，他可能被外部方法所引用，例如作为调用参数传递到其他方法中去，称为方法逃逸</li>
<li>这个对象还有可能被外部线程访问到，譬如赋值给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸</li>
</ol>
<p>如果能证明一个对象不会逃逸则可以为这个变量进行一些高效的优化：</p>
<ul>
<li>栈上分配：如果确定一个对象不会逃逸出方法，那么可以让这个对象在栈上分配内存，对象所占用的内存空间会随着栈帧出栈而销毁。</li>
<li>同步消除：如果确定一个变量不会逃逸出线程，那么就可以消除掉这个变量的同步操作。</li>
<li>标量替换：标量是值一个数据无法被分解成更小的数据，如果可以被继续分解就成为聚合量。如果确定一个对象不会被外部访问，那么就可以不创建这个对象而创建它的若干被使用到的成员变量。将对象拆分后，除了能将它的成员变量在栈上分配和读写外，还可以成为后续进一步的优化手段创建条件。</li>
</ul>
<h2 id="Java与C-C-的编译器对比"><a href="#Java与C-C-的编译器对比" class="headerlink" title="Java与C/C++的编译器对比"></a>Java与C/C++的编译器对比</h2><p>Java虚拟机的即时编译器与C/C++的静态编译期相比，可能会由于以下五个原因而导致输出的本地代码有一些劣势：</p>
<ol>
<li>即时编译器占用的是用户程序的运行时间</li>
<li>Java是动态的类型安全语言，意味着虚拟机会频繁进行动态检查</li>
<li>Java使用虚方法的频率高，意味着运行时对方法接受者进行多态选择频率高，编译器在进行优化（方法内联）的难度大</li>
<li>Java是可以进行动态扩展的，使全局性优化难以进行</li>
<li>Java对象那个的内存分配都是在堆上进行的，只有方法中的局部变量才在栈上分配</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/程序编译与代码优化之编译期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/程序编译与代码优化之编译期/" itemprop="url">程序编译与代码优化之编译期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T19:39:58+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当前提到的编译期指将.java文件转化为.class文件，Java为了让其他不是javac产生的文件（如JPython，JRuby）也能得到编译器优化的好处，所以性能的优化大多放在了后端的即时编译器中。</p>
<h2 id="javac编译过程"><a href="#javac编译过程" class="headerlink" title="javac编译过程"></a>javac编译过程</h2><h3 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h3><p>解析步骤包括了经典程序编译原理中的词法分析和语法分析两个步骤。</p>
<h4 id="词法，语法分析"><a href="#词法，语法分析" class="headerlink" title="词法，语法分析"></a>词法，语法分析</h4><p>词法分析是将源代码的字符流转变为标记（Token）集合，Token是编译过程中的最小元素，关键字，变量名，字面量，运算符都可以成为Token。</p>
<p>语法分析是根据Token序列构造抽象语法树的过程，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包，类型，修饰符，运算符，借口，返回值甚至代码注释。</p>
<h4 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h4><p>符号表是由一组符号地址和符号信息构成的表格，包含了每一个编译单元的抽象语法树的顶级结点，以及package-info.java的顶级结点。</p>
<p>在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，符号表是地址分配的依据。</p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>插入式注解处理器在编译器注解进行处理，可以读取，修改，添加抽象语法树中的任意元素。如果其在矗立著节期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理。</p>
<h3 id="语义分析和字节码生成"><a href="#语义分析和字节码生成" class="headerlink" title="语义分析和字节码生成"></a>语义分析和字节码生成</h3><p>语义分析是对结构上正确的源程序进行上下文有关性质的审查。</p>
<h4 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h4><p>标注检查内容包括变量使用前是否被声明，变量与赋值之间的数据类型是否能匹配等。</p>
<p>还有一个重要的动作是常量折叠，例如int a = 1 + 2,经过常量折叠后, a 就会被折叠为3。</p>
<h4 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h4><p>数据及控制流分析对程序上下文逻辑更进一步的验证，检查出诸如程序局部变量在使用前是否赋值，方法的每条路径是否都有返回值，是否所有的受检查异常都被正确处理。</p>
<p>PS:将局部变量声明为final对运行期是没有任何影响的，变量的不变性仅仅由编译期保障。</p>
<h4 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h4><p>Java最常见的语法糖是泛型，变长数组，自动拆装箱等，他们在编译器还原为基础语法。</p>
<h4 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h4><p>javac编译的最后一个阶段，不仅将之前的生成的信息转换为字节码并且还进行了少量的代码转换工作。</p>
<p>之前提到的实例构造器<init>()方法和类构造器方法<clinit>()就是这个阶段添加到语法树中的。</clinit></init></p>
<h2 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h2><h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>Java中的泛型只在程序源码中出现，在编译后的字节码文件中，就已经替换为了原来的原生类型，并且在相应的地方插入了强转代码。这种实现方法叫做类型擦除。</p>
<p>正是由于类型擦除的原因，泛型擦除成相同的元生类型是无法重载的原因。</p>
<h3 id="自动拆装箱和遍历循环"><a href="#自动拆装箱和遍历循环" class="headerlink" title="自动拆装箱和遍历循环"></a>自动拆装箱和遍历循环</h3><p>自动拆装箱在被变异之后被转换成了对应的包装盒还原方法，遍历循环还原了迭代器的实现，正因此遍历循环必须实现Iterable接口。</p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>编译器会根据布尔值的真假将分之中不成立的代码块消除掉。这一工作将会在编译器解除语法糖阶段完成。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>将java代码转变成字节码的编译器称为前端编译器，因为他只完成了从程序到抽象语法树或者中间字节码的生成，此外还有即时编译器完成从字节码到本地机器代码的生成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/访问网站流程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/访问网站流程/" itemprop="url">访问网站流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T14:31:35+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><ul>
<li><strong>浏览器缓存</strong></li>
<li><strong>系统缓存</strong></li>
<li><strong>路由器缓存</strong></li>
<li><strong>ISP的DNS缓存</strong></li>
<li><strong>根域名服务器搜索</strong></li>
<li><strong>获得IP</strong></li>
</ul>
<h2 id="Http数据包"><a href="#Http数据包" class="headerlink" title="Http数据包"></a>Http数据包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成http数据包</span><br><span class="line">GET http://www.baidu.com/ HTTP/1.1</span><br><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Zune 4.7; InfoPath.3; MS-RTC LM 8)</span><br><span class="line">Accept-Encoding: gzip, deflate, peerdist</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Cookie: BDSFRCVID=H1K_JgC2l434o0a3SlYrhIyDwFLxPM7C3J; H_BDCLCKID_SF=tJAt_C8htDv5HTuRj63D5JcH-UnLqMkDWaOZ0h8-aI-5MbAx-jb6hhFXM-r80nblBTbT2C3nthF0HPonHj8Bej5L3J; BAIDUID=C0E879D1A40237E70E9FA559D40EE0AC:FG=1; BDUT=w5n3C0E879D1A40237E70E9FA559D40EE0AC13914a661370; BDUSS=FEQVdNdjllMTYyYlRxY3ZZbW1hM2htemdqZFVJcWRLWmFBaEtqd1FoTDNXeE5SQUFBQUFBJCQAAAAAAAAAAAoqyysAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEwLjI2LjE5Ny43NwAAAADAxFInAAAAAPcNJlD3DSZQYV; BDRCVFR[eYjbPwSqvSs]=2g3v5sBI-NCpv4EILPoXi4WUvY; Hm_lvt_9f14aaa038bbba8b12ec2a4a3e51d254=1344671219756; Hm_lpvt_9f14aaa038bbba8b12ec2a4a3e51d254=1344671219756</span><br><span class="line">X-P2P-PeerDist: Version=1.0</span><br></pre></td></tr></table></figure>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>TCP 数据包需要设置端口，接收方的Http端口默认是 80,本机的端口是一个1024-65535之间的随机整数。</p>
<p>首先通过TCP三次握手建立连接,通过TCP四次挥手断开连接。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%85%A8%E6%B5%81%E7%A8%8B_1.png" alt="image"></p>
<h2 id="TCP三次握手-建立连接"><a href="#TCP三次握手-建立连接" class="headerlink" title="TCP三次握手(建立连接)"></a>TCP三次握手(建立连接)</h2><ol>
<li><strong>第一次握手:</strong> 客户端发送SYN(syn=x)包到服务器,并进入SYN_SEND状态,等待服务器确认</li>
<li><strong>第二次握手:</strong> 服务器接收到syn包,必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包(syn=y),即SYN+ACK包,此时服务器进入SYN_RECV状态</li>
<li><strong>第三次握手:</strong> 客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,完成三次握手</li>
<li>握手过程中传送的包里不包含数据,三次握手完毕后,客户端和服务端才开始传送数据。理想状态下,TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将一直保持下去</li>
</ol>
<h2 id="TCP四次挥手-释放连接"><a href="#TCP四次挥手-释放连接" class="headerlink" title="TCP四次挥手(释放连接)"></a>TCP四次挥手(释放连接)</h2><p>断开一个TCP连接需要四次挥手</p>
<ol>
<li><strong>第一次挥手:</strong> 主动关闭方发送一个FIN，关闭主动方到被动方的数据传送</li>
<li><strong>第二次挥手:</strong> 被动关闭方收到FIN包后，发送ACK给对方</li>
<li><strong>第三次挥手:</strong> 被动关闭方发送一个FIN，关闭被动方到主动方的数据传送</li>
<li><strong>第四次挥手:</strong> 主动关闭方收到FIN后，发送一个ACK给对方，至此完成四次挥手</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>IP数据包需要知道双方的IP地址,IP数据包由头部()IP 地址信息) + TCP 数据包组成。</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>ARP通过IP地址获得MAC地址,数据帧由头部(MAC地址) + 数据组成。</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>将数据链路层的帧数据转换为bit流。</p>
<h1 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h1><ul>
<li>bit流转换为帧</li>
<li>帧转换为IP数据包</li>
<li>IP数据包转换为TCP数据包</li>
<li>TCP数据包转换为HTTP数据包</li>
<li>生成相应的requst、response对象</li>
<li>生成响应发送客户端</li>
</ul>
<h1 id="客户端收到服务器响应数据"><a href="#客户端收到服务器响应数据" class="headerlink" title="客户端收到服务器响应数据"></a>客户端收到服务器响应数据</h1><ul>
<li>解析response</li>
<li>浏览器根据响应渲染页面</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/OkHttp源码详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/OkHttp源码详解/" itemprop="url">OkHttp源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T21:53:46+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文基于OkHttp 3.12.0版本</strong></p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_OkHttp%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_1.png" alt="image"></p>
<h1 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h1><h2 id="创建OkHttpClient"><a href="#创建OkHttpClient" class="headerlink" title="创建OkHttpClient"></a>创建OkHttpClient</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用Builder模式创建OkHttpClient</span><br><span class="line">public OkHttpClient() &#123;</span><br><span class="line">    this(new OkHttpClient.Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// OkHttpClient中的一些参数</span><br><span class="line">public Builder() &#123;</span><br><span class="line">    // 分发器</span><br><span class="line">    this.dispatcher = new Dispatcher();</span><br><span class="line">    // 协议</span><br><span class="line">    this.protocols = OkHttpClient.DEFAULT_PROTOCOLS;</span><br><span class="line">    // 传输层版本与连接协议</span><br><span class="line">    this.connectionSpecs = OkHttpClient.DEFAULT_CONNECTION_SPECS;</span><br><span class="line">    this.eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">    // 代理选择</span><br><span class="line">    this.proxySelector = ProxySelector.getDefault();</span><br><span class="line">    if (this.proxySelector == null) &#123;</span><br><span class="line">        this.proxySelector = new NullProxySelector();</span><br><span class="line">    &#125;</span><br><span class="line">    // cookie</span><br><span class="line">    this.cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">    // socket工厂</span><br><span class="line">    this.socketFactory = SocketFactory.getDefault();</span><br><span class="line">    // 主机名字确认</span><br><span class="line">    this.hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">    // 证书链</span><br><span class="line">    this.certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">    // 代理身份验证</span><br><span class="line">    this.proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">    // 本地身份验证</span><br><span class="line">    this.authenticator = Authenticator.NONE;</span><br><span class="line">    // 连接池</span><br><span class="line">    this.connectionPool = new ConnectionPool();</span><br><span class="line">    // 域名</span><br><span class="line">    this.dns = Dns.SYSTEM;</span><br><span class="line">    // 安全套接层重定向</span><br><span class="line">    this.followSslRedirects = true;</span><br><span class="line">    // 本地重定向</span><br><span class="line">    this.followRedirects = true;</span><br><span class="line">    // 尝试连接失败</span><br><span class="line">    this.retryOnConnectionFailure = true;</span><br><span class="line">    this.callTimeout = 0;</span><br><span class="line">    // 默认连接超时时间</span><br><span class="line">    this.connectTimeout = 10000;</span><br><span class="line">    // 默认读取超时时间</span><br><span class="line">    this.readTimeout = 10000;</span><br><span class="line">    // 默认写入超时时间</span><br><span class="line">    this.writeTimeout = 10000;</span><br><span class="line">    this.pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发起同步请求"><a href="#发起同步请求" class="headerlink" title="发起同步请求"></a>发起同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 发起一个同步的网络请求</span><br><span class="line">okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 调用了newCall返回一个RealCall对象</span><br><span class="line">Call newCall(Request request) &#123;</span><br><span class="line">        return RealCall.newRealCall(this, request, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 实际调用在RealCall的execute()方法</span><br><span class="line">Response execute() throws IOException &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (this.executed) &#123;</span><br><span class="line">            // 每个call只能执行一次</span><br><span class="line">                throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.executed = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.captureCallStackTrace();</span><br><span class="line">        this.timeout.enter();</span><br><span class="line">        this.eventListener.callStart(this);</span><br><span class="line"></span><br><span class="line">        Response var2;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 通知dispatcher执行call</span><br><span class="line">            this.client.dispatcher().executed(this);</span><br><span class="line">            // 通过一系列拦截操作,实际进行网络请求并且获取结果(责任链模式)</span><br><span class="line">            Response result = this.getResponseWithInterceptorChain();</span><br><span class="line">            if (result == null) &#123;</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var2 = result;</span><br><span class="line">        &#125; catch (IOException var7) &#123;</span><br><span class="line">            IOException e = this.timeoutExit(var7);</span><br><span class="line">            this.eventListener.callFailed(this, e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        // 通知dispatcher执行完毕</span><br><span class="line">            this.client.dispatcher().finished(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">       List&lt;Interceptor&gt; interceptors = new ArrayList();</span><br><span class="line">       // 用户自定义的拦截器</span><br><span class="line">       interceptors.addAll(this.client.interceptors());</span><br><span class="line">       // 负责失败重试以及重定向的拦截器</span><br><span class="line">       interceptors.add(this.retryAndFollowUpInterceptor);</span><br><span class="line">       // 负责将用户请求转换为服务器的请求以及将服务器的响应转换为用户友好响应的拦截器</span><br><span class="line">       interceptors.add(new BridgeInterceptor(this.client.cookieJar()));</span><br><span class="line">       // 负责读取、更新缓存的拦截器</span><br><span class="line">       interceptors.add(new CacheInterceptor(this.client.internalCache()));</span><br><span class="line">       // 负责和服务器建立连接的拦截器</span><br><span class="line">       interceptors.add(new ConnectInterceptor(this.client));</span><br><span class="line">       if (!this.forWebSocket) &#123;</span><br><span class="line">           // 用户自定义的网络拦截器</span><br><span class="line">           interceptors.addAll(this.client.networkInterceptors());</span><br><span class="line">       &#125;</span><br><span class="line">       // 负责向服务器发送请求数据以及读取响应的拦截器</span><br><span class="line">       interceptors.add(new CallServerInterceptor(this.forWebSocket));</span><br><span class="line">       Chain chain = new RealInterceptorChain(interceptors, (StreamAllocation)null, (HttpCodec)null, (RealConnection)null, 0, this.originalRequest, this, this.eventListener, this.client.connectTimeoutMillis(), this.client.readTimeoutMillis(), this.client.writeTimeoutMillis());</span><br><span class="line">       // 开启链式调用(责任链模式)</span><br><span class="line">       return chain.proceed(this.originalRequest);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line">        StreamAllocation streamAllocation = new StreamAllocation(this.client.connectionPool(), this.createAddress(request.url()), call, eventListener, this.callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line">        // 如果未canceled则一直循环</span><br><span class="line">        while(!this.canceled) &#123;</span><br><span class="line">            boolean releaseConnection = true;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 责任链模式 调用下一个拦截器 并且捕获异常进行操作</span><br><span class="line">                response = realChain.proceed(request, streamAllocation, (HttpCodec)null, (RealConnection)null);</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">            &#125; catch (RouteException var19) &#123;</span><br><span class="line">                if (!this.recover(var19.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">                    throw var19.getFirstConnectException();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException var20) &#123;</span><br><span class="line">                boolean requestSendStarted = !(var20 instanceof ConnectionShutdownException);</span><br><span class="line">                if (!this.recover(var20, streamAllocation, requestSendStarted, request)) &#123;</span><br><span class="line">                    throw var20;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed((IOException)null);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder().priorResponse(priorResponse.newBuilder().body((ResponseBody)null).build()).build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            Request followUp;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 构建重定向请求</span><br><span class="line">                followUp = this.followUpRequest(response, streamAllocation.route());</span><br><span class="line">            &#125; catch (IOException var18) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw var18;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Util.closeQuietly(response.body());</span><br><span class="line">            ++followUpCount;</span><br><span class="line">            if (followUpCount &gt; 20) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!this.sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = new StreamAllocation(this.client.connectionPool(), this.createAddress(followUp.url()), call, eventListener, this.callStackTrace);</span><br><span class="line">                this.streamAllocation = streamAllocation;</span><br><span class="line">            &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 赋值为新的重定向请求</span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1L) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, Util.hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // gzip压缩</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = this.cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, this.cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 责任链模式 调用下一个拦截器</span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">        HttpHeaders.receiveHeaders(this.cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">        okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);</span><br><span class="line">        if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            // gzip解压</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder().removeAll(&quot;Content-Encoding&quot;).removeAll(&quot;Content-Length&quot;).build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        // cache利用DiskLruCache进行磁盘缓存</span><br><span class="line">        Response cacheCandidate = this.cache != null ? this.cache.get(chain.request()) : null;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        CacheStrategy strategy = (new Factory(now, chain.request(), cacheCandidate)).get();</span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">        if (this.cache != null) &#123;</span><br><span class="line">            this.cache.trackResponse(strategy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            Util.closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            return (new Builder()).request(chain.request()).protocol(Protocol.HTTP_1_1).code(504).message(&quot;Unsatisfiable Request (only-if-cached)&quot;).body(Util.EMPTY_RESPONSE).sentRequestAtMillis(-1L).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">        &#125; else if (networkRequest == null) &#123;</span><br><span class="line">            return cacheResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Response networkResponse = null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // 责任链模式 调用下一个拦截器</span><br><span class="line">                networkResponse = chain.proceed(networkRequest);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">                    Util.closeQuietly(cacheCandidate.body());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            if (cacheResponse != null) &#123;</span><br><span class="line">                if (networkResponse.code() == 304) &#123;</span><br><span class="line">                    response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</span><br><span class="line">                    networkResponse.body().close();</span><br><span class="line">                    this.cache.trackConditionalCacheHit();</span><br><span class="line">                    this.cache.update(cacheResponse, response);</span><br><span class="line">                    return response;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Util.closeQuietly(cacheResponse.body());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</span><br><span class="line">            if (this.cache != null) &#123;</span><br><span class="line">                if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">                    CacheRequest cacheRequest = this.cache.put(response);</span><br><span class="line">                    return this.cacheWritingResponse(cacheRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        this.cache.remove(networkRequest);</span><br><span class="line">                    &#125; catch (IOException var13) &#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        // 使用httpcodec处理请求,其实现类http1codec与http2codec分别对应着HTTP/1.1 和 HTTP/2 版本的实现</span><br><span class="line">        // httpcodec内部使用Okio对Socket的读写操作进行了封装,Okio对io以及nio进行了封装,可以进行更加便捷高效的io操作</span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(this.client, chain, doExtensiveHealthChecks);</span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line">        // 责任链模式 调用下一个拦截器</span><br><span class="line">        return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 使用httpcodec处理request获取response</span><br><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        RealConnection connection = (RealConnection)realChain.connection();</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        long sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">        httpCodec.writeRequestHeaders(request);</span><br><span class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line">        Builder responseBuilder = null;</span><br><span class="line">        if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</span><br><span class="line">            if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">                httpCodec.flushRequest();</span><br><span class="line">                realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">                responseBuilder = httpCodec.readResponseHeaders(true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseBuilder == null) &#123;</span><br><span class="line">                realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">                long contentLength = request.body().contentLength();</span><br><span class="line">                CallServerInterceptor.CountingSink requestBodyOut = new CallServerInterceptor.CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">                realChain.eventListener().requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">            &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpCodec.finishRequest();</span><br><span class="line">        if (responseBuilder == null) &#123;</span><br><span class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">        int code = response.code();</span><br><span class="line">        if (code == 100) &#123;</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">            response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        realChain.eventListener().responseHeadersEnd(realChain.call(), response);</span><br><span class="line">        if (this.forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0L) &#123;</span><br><span class="line">            throw new ProtocolException(&quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="发起异步请求"><a href="#发起异步请求" class="headerlink" title="发起异步请求"></a>发起异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 异步请求示例</span><br><span class="line">okHttpClient.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onFailure(Call call, IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(Callback responseCallback) &#123;</span><br><span class="line">        // 不允许重复调用</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (this.executed) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.executed = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.captureCallStackTrace();</span><br><span class="line">        this.eventListener.callStart(this);</span><br><span class="line">        this.client.dispatcher().enqueue(new RealCall.AsyncCall(responseCallback));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将请求加入到一个队列中</span><br><span class="line">void enqueue(AsyncCall call) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            this.readyAsyncCalls.add(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.promoteAndExecute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">boolean promoteAndExecute() &#123;</span><br><span class="line">        assert !Thread.holdsLock(this);</span><br><span class="line"></span><br><span class="line">        List&lt;AsyncCall&gt; executableCalls = new ArrayList();</span><br><span class="line">        boolean isRunning;</span><br><span class="line">        AsyncCall asyncCall;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            Iterator i = this.readyAsyncCalls.iterator();</span><br><span class="line"></span><br><span class="line">            while(true) &#123;</span><br><span class="line">                if (i.hasNext()) &#123;</span><br><span class="line">                    asyncCall = (AsyncCall)i.next();</span><br><span class="line">                    if (this.runningAsyncCalls.size() &lt; this.maxRequests) &#123;</span><br><span class="line">                        if (this.runningCallsForHost(asyncCall) &lt; this.maxRequestsPerHost) &#123;</span><br><span class="line">                            i.remove();</span><br><span class="line">                            executableCalls.add(asyncCall);</span><br><span class="line">                            this.runningAsyncCalls.add(asyncCall);</span><br><span class="line">                        &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                isRunning = this.runningCallsCount() &gt; 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = 0;</span><br><span class="line"></span><br><span class="line">        for(int size = executableCalls.size(); i &lt; size; ++i) &#123;</span><br><span class="line">            asyncCall = (AsyncCall)executableCalls.get(i);</span><br><span class="line">            // 在线程池中执行call的execute()方法</span><br><span class="line">            asyncCall.executeOn(this.executorService());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/mynameishuangshuai/article/details/51303446" target="_blank" rel="noopener">OkHttp官方教程解析-彻底入门OkHttp使用</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列：拆 OkHttp</a></li>
<li><a href="https://juejin.im/entry/597800116fb9a06baf2eeb63" target="_blank" rel="noopener">OkHttp解析</a> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/Glide源码详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/Glide源码详解/" itemprop="url">Glide源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-09T22:15:59+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文基于Glide 4.5.0版本</strong></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Volatile + Double-Checked Locking实现Glide的单例</span><br><span class="line">public static Glide get(@NonNull Context context) &#123;</span><br><span class="line">    if (glide == null) &#123;</span><br><span class="line">      synchronized (Glide.class) &#123;</span><br><span class="line">        if (glide == null) &#123;</span><br><span class="line">          checkAndInitializeGlide(context);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过构建者模式构造Glide</span><br><span class="line">Glide glide = builder.build(applicationContext);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// GlideBuilder的build方法返回Glide</span><br><span class="line">return new Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptions.lock(),</span><br><span class="line">        defaultTransitionOptions);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Glide的几个重要的构造参数如下:</p>
<ul>
<li><strong>arrayPool 数组池</strong></li>
<li><strong>memoryCache 内存缓存</strong></li>
<li><strong>bitmapPool 图片池</strong></li>
<li><strong>engine 引擎类</strong></li>
</ul>
<h2 id="ArrayPool"><a href="#ArrayPool" class="headerlink" title="ArrayPool"></a>ArrayPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定arrayPool则使用默认的Lru缓存策略</span><br><span class="line">if (arrayPool == null) &#123;</span><br><span class="line">      // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定memoryCache则使用默认的Lru缓存策略</span><br><span class="line">if (memoryCache == null) &#123;</span><br><span class="line">    // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">  memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BitmapPool"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定memoryCache则使用默认的缓存策略</span><br><span class="line">if (bitmapPool == null) &#123;</span><br><span class="line">      int size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">      if (size &gt; 0) &#123;</span><br><span class="line">      // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">        bitmapPool = new LruBitmapPool(size);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      // 不做缓存</span><br><span class="line">        bitmapPool = new BitmapPoolAdapter();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemorySizeCalculator"><a href="#MemorySizeCalculator" class="headerlink" title="MemorySizeCalculator"></a>MemorySizeCalculator</h2><h3 id="ArrayPool缓存池大小"><a href="#ArrayPool缓存池大小" class="headerlink" title="ArrayPool缓存池大小"></a>ArrayPool缓存池大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 缓存池大小取决于当前是否为低内存机型</span><br><span class="line">// 默认大小为4MB,如果当前为低内存机型则缓存池设为2MB</span><br><span class="line">arrayPoolSize =</span><br><span class="line">    isLowMemoryDevice(builder.activityManager)</span><br><span class="line">        ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR</span><br><span class="line">        : builder.arrayPoolSizeBytes;</span><br></pre></td></tr></table></figure>
<h3 id="BitmapPool与MemoryCache缓存池大小"><a href="#BitmapPool与MemoryCache缓存池大小" class="headerlink" title="BitmapPool与MemoryCache缓存池大小"></a>BitmapPool与MemoryCache缓存池大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取可用内存大小</span><br><span class="line">getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,</span><br><span class="line">      float lowMemoryMaxSizeMultiplier) &#123;</span><br><span class="line">    // 每个进程最大可用内存</span><br><span class="line">    final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;</span><br><span class="line">    final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);</span><br><span class="line">    // 如果是低内存手机 则最大内存*0.4 否则为最大内存*0.33</span><br><span class="line">    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier</span><br><span class="line">        : maxSizeMultiplier));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取屏幕宽度    </span><br><span class="line">int widthPixels = builder.screenDimensions.getWidthPixels();</span><br><span class="line">// 获取屏幕高度</span><br><span class="line">int heightPixels = builder.screenDimensions.getHeightPixels();</span><br><span class="line">// 当前屏幕宽度*屏幕高度*4</span><br><span class="line">int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;</span><br><span class="line">// 图片缓存池大小为屏幕尺寸大小*4(若当前版本大于等于Android O,则直接为屏幕尺寸大小*1)</span><br><span class="line">int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);</span><br><span class="line">// 内存缓存大小为屏幕尺寸大小*2</span><br><span class="line">int targetMemoryCacheSize = Math.round(screenSize *builder.memoryCacheScreens);</span><br><span class="line">// 可用内存为可用内存大小减去ArrayPool缓存池大小</span><br><span class="line">int availableSize = maxSize - arrayPoolSize;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否超过最大值,否则就等比缩小</span><br><span class="line">if (targetMemoryCacheSize + targetBitmapPoolSize &lt;= availableSize) &#123;</span><br><span class="line">      memoryCacheSize = targetMemoryCacheSize;</span><br><span class="line">      bitmapPoolSize = targetBitmapPoolSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      float part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">      memoryCacheSize = Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">      bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定engine则使用默认的engine</span><br><span class="line">if (engine == null) &#123;</span><br><span class="line">      engine =</span><br><span class="line">          new Engine(</span><br><span class="line">              memoryCache,</span><br><span class="line">              diskCacheFactory,</span><br><span class="line">              diskCacheExecutor,</span><br><span class="line">              sourceExecutor,</span><br><span class="line">              GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">              GlideExecutor.newAnimationExecutor(),</span><br><span class="line">              isActiveResourceRetentionAllowed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>engine的几个重要参数:</p>
<ul>
<li><strong>memoryCache 内存缓存</strong></li>
<li><strong>diskCacheFactory 本地缓存</strong></li>
<li><strong>diskCacheExecutor 本地缓存线程池</strong></li>
<li><strong>sourceExecutor 处理源资源线程池</strong></li>
</ul>
<h3 id="MemoryCache-1"><a href="#MemoryCache-1" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><p>同上。</p>
<h3 id="DiskCacheFactory"><a href="#DiskCacheFactory" class="headerlink" title="DiskCacheFactory"></a>DiskCacheFactory</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Factory &#123;</span><br><span class="line">  // 默认大小为250MB</span><br><span class="line">  int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 *</span><br><span class="line">  // 默认缓存目录为image_manager_disk_cache</span><br><span class="line">  String DEFAULT_DISK_CACHE_DIR = &quot;image_manager_disk_cache&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DiskCacheExecutor"><a href="#DiskCacheExecutor" class="headerlink" title="DiskCacheExecutor"></a>DiskCacheExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">newDiskCacheExecutor() &#123;</span><br><span class="line">    return newDiskCacheExecutor(</span><br><span class="line">    // 默认可获得处理器大小为1</span><br><span class="line">        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,</span><br><span class="line">        DEFAULT_DISK_CACHE_EXECUTOR_NAME,</span><br><span class="line">        UncaughtThrowableStrategy.DEFAULT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SourceExecutor"><a href="#SourceExecutor" class="headerlink" title="SourceExecutor"></a>SourceExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可获得处理器大小为当前可用处理器大小与4的最小值</span><br><span class="line">bestThreadCount =</span><br><span class="line">          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());</span><br></pre></td></tr></table></figure>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><h2 id="with的重载"><a href="#with的重载" class="headerlink" title="with的重载"></a>with的重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 返回一个RequestManager对象</span><br><span class="line">  * @see #with(android.app.Activity)</span><br><span class="line">  * @see #with(android.app.Fragment)</span><br><span class="line">  * @see #with(android.support.v4.app.Fragment)</span><br><span class="line">  * @see #with(android.support.v4.app.FragmentActivity)</span><br><span class="line">  */</span><br><span class="line"> @NonNull</span><br><span class="line"> public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">   return getRetriever(context).get(context);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步生命周期"><a href="#同步生命周期" class="headerlink" title="同步生命周期"></a>同步生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 通过传递Context类型的不同执行相似的逻辑</span><br><span class="line">RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">      if (context instanceof FragmentActivity) &#123;</span><br><span class="line">        return get((FragmentActivity) context);</span><br><span class="line">      &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">        return get((Activity) context);</span><br><span class="line">      &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">        return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 以传递Context类型为activity为例代码如下</span><br><span class="line">// 其他类型逻辑类似 都是获取FragmentManager</span><br><span class="line">get(@NonNull Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      return fragmentGet(activity, fm, null /*parentHint*/);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个无界面的Fragment,让请求和activity的生命周期同步</span><br><span class="line">fragmentGet(@NonNull Context context,</span><br><span class="line">      @NonNull android.app.FragmentManager fm,</span><br><span class="line">      @Nullable android.app.Fragment parentHint) &#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">      // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 如果在子线程调用或者传入Context类型为application,则请求与Application生命周期同步</span><br><span class="line">RequestManagerRetriever(@Nullable RequestManagerFactory factory) &#123;</span><br><span class="line">    this.factory = factory != null ? factory : DEFAULT_FACTORY;</span><br><span class="line">    handler = new Handler(Looper.getMainLooper(), this /* Callback */);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private RequestManager getApplicationManager(@NonNull Context context) &#123;</span><br><span class="line">    // Either an application context or we&apos;re on a background thread.</span><br><span class="line">    if (applicationManager == null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        if (applicationManager == null) &#123;</span><br><span class="line">          // Normally pause/resume is taken care of by the fragment we add to the fragment or</span><br><span class="line">          // activity. However, in this case since the manager attached to the application will not</span><br><span class="line">          // receive lifecycle events, we must force the manager to start resumed using</span><br><span class="line">          // ApplicationLifecycle.</span><br><span class="line"></span><br><span class="line">          // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  new ApplicationLifecycle(),</span><br><span class="line">                  new EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以加载文件图片为例,将返回一个RequestBuilder对象,支持链式调用</span><br><span class="line">RequestBuilder&lt;Drawable&gt; load(@Nullable File file) &#123;</span><br><span class="line">    return asDrawable().load(string);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="into"><a href="#into" class="headerlink" title="into"></a>into</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">into(@NonNull ImageView view) &#123;</span><br><span class="line">    // into方法必须要在主线程调用,否则抛出异常</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    RequestOptions requestOptions = this.requestOptions;</span><br><span class="line">    // 未调用transform而且设置了scaleType则会对图片做处理</span><br><span class="line">    if (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != null) &#123;</span><br><span class="line">      switch (view.getScaleType()) &#123;</span><br><span class="line">        case CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_CENTER:</span><br><span class="line">        case FIT_START:</span><br><span class="line">        case FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER:</span><br><span class="line">        case MATRIX:</span><br><span class="line">        default:</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return into(</span><br><span class="line">        // 将View封装为Target</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        /*targetListener=*/ null,</span><br><span class="line">        requestOptions);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">into(</span><br><span class="line">      @NonNull Y target,</span><br><span class="line">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">      @NonNull RequestOptions options) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    if (!isModelSet) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options = options.autoClone();</span><br><span class="line">    // 构建request</span><br><span class="line">    Request request = buildRequest(target, targetListener, options);</span><br><span class="line"></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    // 如果存在之前的相同请求而且未设置不允许内存缓存</span><br><span class="line">    if (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      // 释放当前request以及相关资源</span><br><span class="line">      request.recycle();</span><br><span class="line">      // 如果请求完成,将重新开始请求</span><br><span class="line">      // 如果请求正在运行,则继续运行</span><br><span class="line">      if (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        // 直接使用之前的请求来进行优化操作</span><br><span class="line">        // 例如跳过设置占位符,跟踪与取消跟踪目标,获取view尺寸</span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除target之前的request</span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    // 绑定request</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    // 跟踪request</span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runRequest(Request request) &#123;</span><br><span class="line">    // 加入request列表</span><br><span class="line">    requests.add(request);</span><br><span class="line">    if (!isPaused) &#123;</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 最终进入到Engine的load()</span><br><span class="line">// 尝试从ActiveResources中获取</span><br><span class="line">// ActiveResources中存放一个弱引用的map,存储使用中的资源,为了防止内存不足清除cache后不影响使用中的资源</span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    if (active != null) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">// 如果ActiveResources未能获取到则到MemoryCache中获取</span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 如果获取到则直接返回</span><br><span class="line">EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    if (current != null) &#123;</span><br><span class="line">      current.addCallback(cb);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return new LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line">// 创建engineJob</span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line">            </span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    // 启动decodeJob</span><br><span class="line">    engineJob.start(decodeJob);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start(DecodeJob&lt;R&gt; decodeJob) &#123;</span><br><span class="line">    this.decodeJob = decodeJob;</span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">    // 尝试从磁盘中获取</span><br><span class="line">    // 磁盘获取的逻辑模式为先尝试获取处理后的图片然后尝试获取原图</span><br><span class="line">        ? diskCacheExecutor</span><br><span class="line">    // 从网络中获取</span><br><span class="line">        : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/08/Glide和Picasso对比/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/Glide和Picasso对比/" itemprop="url">Glide和Picasso对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-08T21:07:44+08:00">
                2018-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Glide和Picasso是目前Android开发中很流行的图片加载库，Glide库和Picasso库也有极大的相似性，其区别主要体现在如下几个方面。</p>
<h1 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h1><p>Glide库的大小要远远大于Picasso。<br><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Glide%20%E5%92%8C%20Picasso%E5%AF%B9%E6%AF%94_1.png" alt="image"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>Glide支持gif</li>
<li>Glide支持视频略缩图</li>
<li>Glide支持与Acitivty生命周期联动</li>
<li>Glide默认加载<strong>RGB_565</strong>(2字节),Picasso默认加载<strong>ARGB8888</strong>(4字节)</li>
<li>Glide提供了更多配置可供定制化</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ul>
<li><strong>Picasso:</strong> 下载图片然后在本地缓存完整图片。如果需要resize,也是对原图进行resize。</li>
<li><strong>Glide:</strong> 下载图片,然后改变图片大小以适应不同需求,最后缓存到本地。同一张图片如果不同ImageView加载可能缓存多张图片。</li>
</ul>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>由于Glide缓存改变大小后的图片,而Picasso缓存原图,所以Glide使用的内存要小于Picasso。</p>
<h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><p>由于缓存机制的不同,Picasso从缓存中读取原图要先resize,而Glide则直接读取缓存图片,所以加载速度Glide优于Picasso。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Dawn</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/delaube" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="lu923418335@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawn</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
