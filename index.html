<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Dawn">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dawn">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dawn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Dawn</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dawn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/程序编译与代码优化之运行期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/程序编译与代码优化之运行期/" itemprop="url">程序编译与代码优化之运行期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T21:09:45+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，虚拟机会将这些代码翻译成本地平台相关的机器码，并且进行各种层次的优化，完成这个任务的编译器叫做即时编译器（JIT编译器）。</p>
<h2 id="HotSpot内的即时编译器"><a href="#HotSpot内的即时编译器" class="headerlink" title="HotSpot内的即时编译器"></a>HotSpot内的即时编译器</h2><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器可以省去编译的时间，立即执行。编译器可以将代码编译成本地代码，获得更高的执行效率。</p>
<p>解释器可以作为编译器激进优化的一个逃生门，让编译器根据概率选择一些大多数时候能提升运行素的的优化手段，如果假设不成立可以通过逆优化退回到解释状态据需执行。</p>
<h3 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h3><p>在运行阶段被即时编译器编译的热点代码有两类：</p>
<ol>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ol>
<p>这两种情况JIT编译器都会把整个方法作为编译对象。</p>
<p>判断一段代码是不是热点代码的行为成为热点探测，目前热点探测判定标准有两种：</p>
<ol>
<li>基于采样的热点探测：虚拟机会周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是热点方法。</li>
<li>基于计数器的热点探测：虚拟机会为每个方法甚至是代码块建立计数器，统计执行次数，如果超过某个阈值就认为他是热点方法。</li>
</ol>
<p>在HotSpot虚拟机中采用了第二种方法，为每个方法准备了两类计数器：方法调用计数器和回边计数器。</p>
<p>方法调用计数器其交互过程如下所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%9F_1.png" alt="image"></p>
<p>方法调用计数器统计的是一段时间内方法的执行频率。当超过一定时间限度此方法调用次数仍不足以让它提交给即时编译器编译，那么他的调用计数器就会较少一半。</p>
<p>回边计数器作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令成为回边。回边计数器的交互过程如下所示：</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%9F_2.png" alt="image"></p>
<p>回边计数器统计的是方法循环执行的绝对次数，没有计数热度衰减的过程。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>后台编译分三个阶段：</p>
<ol>
<li>一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR），HIR使用静态单分配的形式来代表代码值，在此之前会完成如方法内联，常量传播等优化。</li>
<li>一个平台相关的后端从HIR中产生低级中间代码表示，自此之前完成如空值检查消除，范围检查消除等操作。</li>
<li>在平台相关的后端使用现行扫描算法在LIR上分配寄存器，并且在LIR上做窥孔优化，然后产生机器代码。</li>
</ol>
<h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>如果一个表达式E已经计算过了，而且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，字需要直接用前面计算过的表达式结果代替E就可以了。</p>
<h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0, foo.length)之内，拿在整个循环中就可以把数组的上下界消除，节约了多次的条件判定操作。</p>
<p>减少隐式开销的方法除了将这种数组边界检查优化尽可能提前到编译器完成之外，还有一种方法——隐式异常处理，java中空指针检查和算术异常检查都采用这种方法。</p>
<p>Java伪代码来表示虚拟机访问foo.value的过程示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(foo != null)&#123;</span><br><span class="line">    return foo.value;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    throw new NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用隐式优化后，虚拟机将上面的代码表示的访问过程变成下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    return foo.value;</span><br><span class="line">&#125;catch(segment_fault)&#123;</span><br><span class="line">    uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机会注册一个Segment Fault信号的异常处理器，当foo不为空时，对value的访问是不会额外消耗一次对foo判空的开销。若foo为空，必须转入到异常处理器中恢复并且抛出空指针异常，这个过程从用户态转入内核态处理然后再回到用户态，速度 非常慢。</p>
<p>如果foo极少为空的时候，优化是值得的。HotSpot虚拟机会根据运行期间收集到的Profile信息自动选择最优方案。</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>Java虚拟机设计团队为了解决虚方法内联问题引入了一个名为类型继承关系分析（CHA）的技术。</p>
<p>编译器在进行内联时，如果是非虚方法直接进行内联即可。</p>
<p>如果是虚方法，则向CHA查询此方法在当前程序下是否有多个版本可以选择，如果查询到只有一个版本可以进行内联，不过这种内联属于激进优化，需要预留一个逃生门，称为守护内联。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的继承关系发生变化的类，那么这个内链优化的代码就可以一直执行下去。如果加载了导致继承关系发生变化的新类，那就要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</p>
<p>如果CHA查询到多个版本的目标方法可供选择，则编译器会使用内联缓存来完成方法内联。它的工作原理是：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接受者的版本信息，而且每次进行方法调用时都比较接受者版本，如果以后进来的每次调用的方法接受者版本都是一样的，那么这个内联还可以一直用下去。如果发生了不一致的情况，就说明程序使用了虚方法的多态特性，这是会取消内敛，查找虚方法表进行方法分派。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ol>
<li>当一个对象在方法中被定义后，他可能被外部方法所引用，例如作为调用参数传递到其他方法中去，称为方法逃逸</li>
<li>这个对象还有可能被外部线程访问到，譬如赋值给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸</li>
</ol>
<p>如果能证明一个对象不会逃逸则可以为这个变量进行一些高效的优化：</p>
<ul>
<li>栈上分配：如果确定一个对象不会逃逸出方法，那么可以让这个对象在栈上分配内存，对象所占用的内存空间会随着栈帧出栈而销毁。</li>
<li>同步消除：如果确定一个变量不会逃逸出线程，那么就可以消除掉这个变量的同步操作。</li>
<li>标量替换：标量是值一个数据无法被分解成更小的数据，如果可以被继续分解就成为聚合量。如果确定一个对象不会被外部访问，那么就可以不创建这个对象而创建它的若干被使用到的成员变量。将对象拆分后，除了能将它的成员变量在栈上分配和读写外，还可以成为后续进一步的优化手段创建条件。</li>
</ul>
<h2 id="Java与C-C-的编译器对比"><a href="#Java与C-C-的编译器对比" class="headerlink" title="Java与C/C++的编译器对比"></a>Java与C/C++的编译器对比</h2><p>Java虚拟机的即时编译器与C/C++的静态编译期相比，可能会由于以下五个原因而导致输出的本地代码有一些劣势：</p>
<ol>
<li>即时编译器占用的是用户程序的运行时间</li>
<li>Java是动态的类型安全语言，意味着虚拟机会频繁进行动态检查</li>
<li>Java使用虚方法的频率高，意味着运行时对方法接受者进行多态选择频率高，编译器在进行优化（方法内联）的难度大</li>
<li>Java是可以进行动态扩展的，使全局性优化难以进行</li>
<li>Java对象那个的内存分配都是在堆上进行的，只有方法中的局部变量才在栈上分配</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/程序编译与代码优化之编译期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/程序编译与代码优化之编译期/" itemprop="url">程序编译与代码优化之编译期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T19:39:58+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当前提到的编译期指将.java文件转化为.class文件，Java为了让其他不是javac产生的文件（如JPython，JRuby）也能得到编译器优化的好处，所以性能的优化大多放在了后端的即时编译器中。</p>
<h2 id="javac编译过程"><a href="#javac编译过程" class="headerlink" title="javac编译过程"></a>javac编译过程</h2><h3 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h3><p>解析步骤包括了经典程序编译原理中的词法分析和语法分析两个步骤。</p>
<h4 id="词法，语法分析"><a href="#词法，语法分析" class="headerlink" title="词法，语法分析"></a>词法，语法分析</h4><p>词法分析是将源代码的字符流转变为标记（Token）集合，Token是编译过程中的最小元素，关键字，变量名，字面量，运算符都可以成为Token。</p>
<p>语法分析是根据Token序列构造抽象语法树的过程，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包，类型，修饰符，运算符，借口，返回值甚至代码注释。</p>
<h4 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h4><p>符号表是由一组符号地址和符号信息构成的表格，包含了每一个编译单元的抽象语法树的顶级结点，以及package-info.java的顶级结点。</p>
<p>在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，符号表是地址分配的依据。</p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>插入式注解处理器在编译器注解进行处理，可以读取，修改，添加抽象语法树中的任意元素。如果其在矗立著节期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理。</p>
<h3 id="语义分析和字节码生成"><a href="#语义分析和字节码生成" class="headerlink" title="语义分析和字节码生成"></a>语义分析和字节码生成</h3><p>语义分析是对结构上正确的源程序进行上下文有关性质的审查。</p>
<h4 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h4><p>标注检查内容包括变量使用前是否被声明，变量与赋值之间的数据类型是否能匹配等。</p>
<p>还有一个重要的动作是常量折叠，例如int a = 1 + 2,经过常量折叠后, a 就会被折叠为3。</p>
<h4 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h4><p>数据及控制流分析对程序上下文逻辑更进一步的验证，检查出诸如程序局部变量在使用前是否赋值，方法的每条路径是否都有返回值，是否所有的受检查异常都被正确处理。</p>
<p>PS:将局部变量声明为final对运行期是没有任何影响的，变量的不变性仅仅由编译期保障。</p>
<h4 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h4><p>Java最常见的语法糖是泛型，变长数组，自动拆装箱等，他们在编译器还原为基础语法。</p>
<h4 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h4><p>javac编译的最后一个阶段，不仅将之前的生成的信息转换为字节码并且还进行了少量的代码转换工作。</p>
<p>之前提到的实例构造器<init>()方法和类构造器方法<clinit>()就是这个阶段添加到语法树中的。</clinit></init></p>
<h2 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h2><h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>Java中的泛型只在程序源码中出现，在编译后的字节码文件中，就已经替换为了原来的原生类型，并且在相应的地方插入了强转代码。这种实现方法叫做类型擦除。</p>
<p>正是由于类型擦除的原因，泛型擦除成相同的元生类型是无法重载的原因。</p>
<h3 id="自动拆装箱和遍历循环"><a href="#自动拆装箱和遍历循环" class="headerlink" title="自动拆装箱和遍历循环"></a>自动拆装箱和遍历循环</h3><p>自动拆装箱在被变异之后被转换成了对应的包装盒还原方法，遍历循环还原了迭代器的实现，正因此遍历循环必须实现Iterable接口。</p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>编译器会根据布尔值的真假将分之中不成立的代码块消除掉。这一工作将会在编译器解除语法糖阶段完成。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>将java代码转变成字节码的编译器称为前端编译器，因为他只完成了从程序到抽象语法树或者中间字节码的生成，此外还有即时编译器完成从字节码到本地机器代码的生成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/访问网站流程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/访问网站流程/" itemprop="url">访问网站流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T14:31:35+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><ul>
<li><strong>浏览器缓存</strong></li>
<li><strong>系统缓存</strong></li>
<li><strong>路由器缓存</strong></li>
<li><strong>ISP的DNS缓存</strong></li>
<li><strong>根域名服务器搜索</strong></li>
<li><strong>获得IP</strong></li>
</ul>
<h2 id="Http数据包"><a href="#Http数据包" class="headerlink" title="Http数据包"></a>Http数据包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成http数据包</span><br><span class="line">GET http://www.baidu.com/ HTTP/1.1</span><br><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Zune 4.7; InfoPath.3; MS-RTC LM 8)</span><br><span class="line">Accept-Encoding: gzip, deflate, peerdist</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Cookie: BDSFRCVID=H1K_JgC2l434o0a3SlYrhIyDwFLxPM7C3J; H_BDCLCKID_SF=tJAt_C8htDv5HTuRj63D5JcH-UnLqMkDWaOZ0h8-aI-5MbAx-jb6hhFXM-r80nblBTbT2C3nthF0HPonHj8Bej5L3J; BAIDUID=C0E879D1A40237E70E9FA559D40EE0AC:FG=1; BDUT=w5n3C0E879D1A40237E70E9FA559D40EE0AC13914a661370; BDUSS=FEQVdNdjllMTYyYlRxY3ZZbW1hM2htemdqZFVJcWRLWmFBaEtqd1FoTDNXeE5SQUFBQUFBJCQAAAAAAAAAAAoqyysAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEwLjI2LjE5Ny43NwAAAADAxFInAAAAAPcNJlD3DSZQYV; BDRCVFR[eYjbPwSqvSs]=2g3v5sBI-NCpv4EILPoXi4WUvY; Hm_lvt_9f14aaa038bbba8b12ec2a4a3e51d254=1344671219756; Hm_lpvt_9f14aaa038bbba8b12ec2a4a3e51d254=1344671219756</span><br><span class="line">X-P2P-PeerDist: Version=1.0</span><br></pre></td></tr></table></figure>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>TCP 数据包需要设置端口，接收方的Http端口默认是 80,本机的端口是一个1024-65535之间的随机整数。</p>
<p>首先通过TCP三次握手建立连接,通过TCP四次挥手断开连接。</p>
<p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%85%A8%E6%B5%81%E7%A8%8B_1.png" alt="image"></p>
<h2 id="TCP三次握手-建立连接"><a href="#TCP三次握手-建立连接" class="headerlink" title="TCP三次握手(建立连接)"></a>TCP三次握手(建立连接)</h2><ol>
<li><strong>第一次握手:</strong> 客户端发送SYN(syn=x)包到服务器,并进入SYN_SEND状态,等待服务器确认</li>
<li><strong>第二次握手:</strong> 服务器接收到syn包,必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包(syn=y),即SYN+ACK包,此时服务器进入SYN_RECV状态</li>
<li><strong>第三次握手:</strong> 客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,完成三次握手</li>
<li>握手过程中传送的包里不包含数据,三次握手完毕后,客户端和服务端才开始传送数据。理想状态下,TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将一直保持下去</li>
</ol>
<h2 id="TCP四次挥手-释放连接"><a href="#TCP四次挥手-释放连接" class="headerlink" title="TCP四次挥手(释放连接)"></a>TCP四次挥手(释放连接)</h2><p>断开一个TCP连接需要四次挥手</p>
<ol>
<li><strong>第一次挥手:</strong> 主动关闭方发送一个FIN，关闭主动方到被动方的数据传送</li>
<li><strong>第二次挥手:</strong> 被动关闭方收到FIN包后，发送ACK给对方</li>
<li><strong>第三次挥手:</strong> 被动关闭方发送一个FIN，关闭被动方到主动方的数据传送</li>
<li><strong>第四次挥手:</strong> 主动关闭方收到FIN后，发送一个ACK给对方，至此完成四次挥手</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>IP数据包需要知道双方的IP地址,IP数据包由头部()IP 地址信息) + TCP 数据包组成。</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>ARP通过IP地址获得MAC地址,数据帧由头部(MAC地址) + 数据组成。</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>将数据链路层的帧数据转换为bit流。</p>
<h1 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h1><ul>
<li>bit流转换为帧</li>
<li>帧转换为IP数据包</li>
<li>IP数据包转换为TCP数据包</li>
<li>TCP数据包转换为HTTP数据包</li>
<li>生成相应的requst、response对象</li>
<li>生成响应发送客户端</li>
</ul>
<h1 id="客户端收到服务器响应数据"><a href="#客户端收到服务器响应数据" class="headerlink" title="客户端收到服务器响应数据"></a>客户端收到服务器响应数据</h1><ul>
<li>解析response</li>
<li>浏览器根据响应渲染页面</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/OkHttp源码详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/OkHttp源码详解/" itemprop="url">OkHttp源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T21:53:46+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文基于OkHttp 3.12.0版本</strong></p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_OkHttp%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_1.png" alt="image"></p>
<h1 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h1><h2 id="创建OkHttpClient"><a href="#创建OkHttpClient" class="headerlink" title="创建OkHttpClient"></a>创建OkHttpClient</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用Builder模式创建OkHttpClient</span><br><span class="line">public OkHttpClient() &#123;</span><br><span class="line">    this(new OkHttpClient.Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// OkHttpClient中的一些参数</span><br><span class="line">public Builder() &#123;</span><br><span class="line">    // 分发器</span><br><span class="line">    this.dispatcher = new Dispatcher();</span><br><span class="line">    // 协议</span><br><span class="line">    this.protocols = OkHttpClient.DEFAULT_PROTOCOLS;</span><br><span class="line">    // 传输层版本与连接协议</span><br><span class="line">    this.connectionSpecs = OkHttpClient.DEFAULT_CONNECTION_SPECS;</span><br><span class="line">    this.eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">    // 代理选择</span><br><span class="line">    this.proxySelector = ProxySelector.getDefault();</span><br><span class="line">    if (this.proxySelector == null) &#123;</span><br><span class="line">        this.proxySelector = new NullProxySelector();</span><br><span class="line">    &#125;</span><br><span class="line">    // cookie</span><br><span class="line">    this.cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">    // socket工厂</span><br><span class="line">    this.socketFactory = SocketFactory.getDefault();</span><br><span class="line">    // 主机名字确认</span><br><span class="line">    this.hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">    // 证书链</span><br><span class="line">    this.certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">    // 代理身份验证</span><br><span class="line">    this.proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">    // 本地身份验证</span><br><span class="line">    this.authenticator = Authenticator.NONE;</span><br><span class="line">    // 连接池</span><br><span class="line">    this.connectionPool = new ConnectionPool();</span><br><span class="line">    // 域名</span><br><span class="line">    this.dns = Dns.SYSTEM;</span><br><span class="line">    // 安全套接层重定向</span><br><span class="line">    this.followSslRedirects = true;</span><br><span class="line">    // 本地重定向</span><br><span class="line">    this.followRedirects = true;</span><br><span class="line">    // 尝试连接失败</span><br><span class="line">    this.retryOnConnectionFailure = true;</span><br><span class="line">    this.callTimeout = 0;</span><br><span class="line">    // 默认连接超时时间</span><br><span class="line">    this.connectTimeout = 10000;</span><br><span class="line">    // 默认读取超时时间</span><br><span class="line">    this.readTimeout = 10000;</span><br><span class="line">    // 默认写入超时时间</span><br><span class="line">    this.writeTimeout = 10000;</span><br><span class="line">    this.pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发起同步请求"><a href="#发起同步请求" class="headerlink" title="发起同步请求"></a>发起同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 发起一个同步的网络请求</span><br><span class="line">okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 调用了newCall返回一个RealCall对象</span><br><span class="line">Call newCall(Request request) &#123;</span><br><span class="line">        return RealCall.newRealCall(this, request, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 实际调用在RealCall的execute()方法</span><br><span class="line">Response execute() throws IOException &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (this.executed) &#123;</span><br><span class="line">            // 每个call只能执行一次</span><br><span class="line">                throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.executed = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.captureCallStackTrace();</span><br><span class="line">        this.timeout.enter();</span><br><span class="line">        this.eventListener.callStart(this);</span><br><span class="line"></span><br><span class="line">        Response var2;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 通知dispatcher执行call</span><br><span class="line">            this.client.dispatcher().executed(this);</span><br><span class="line">            // 通过一系列拦截操作,实际进行网络请求并且获取结果(责任链模式)</span><br><span class="line">            Response result = this.getResponseWithInterceptorChain();</span><br><span class="line">            if (result == null) &#123;</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var2 = result;</span><br><span class="line">        &#125; catch (IOException var7) &#123;</span><br><span class="line">            IOException e = this.timeoutExit(var7);</span><br><span class="line">            this.eventListener.callFailed(this, e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        // 通知dispatcher执行完毕</span><br><span class="line">            this.client.dispatcher().finished(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">       List&lt;Interceptor&gt; interceptors = new ArrayList();</span><br><span class="line">       // 用户自定义的拦截器</span><br><span class="line">       interceptors.addAll(this.client.interceptors());</span><br><span class="line">       // 负责失败重试以及重定向的拦截器</span><br><span class="line">       interceptors.add(this.retryAndFollowUpInterceptor);</span><br><span class="line">       // 负责将用户请求转换为服务器的请求以及将服务器的响应转换为用户友好响应的拦截器</span><br><span class="line">       interceptors.add(new BridgeInterceptor(this.client.cookieJar()));</span><br><span class="line">       // 负责读取、更新缓存的拦截器</span><br><span class="line">       interceptors.add(new CacheInterceptor(this.client.internalCache()));</span><br><span class="line">       // 负责和服务器建立连接的拦截器</span><br><span class="line">       interceptors.add(new ConnectInterceptor(this.client));</span><br><span class="line">       if (!this.forWebSocket) &#123;</span><br><span class="line">           // 用户自定义的网络拦截器</span><br><span class="line">           interceptors.addAll(this.client.networkInterceptors());</span><br><span class="line">       &#125;</span><br><span class="line">       // 负责向服务器发送请求数据以及读取响应的拦截器</span><br><span class="line">       interceptors.add(new CallServerInterceptor(this.forWebSocket));</span><br><span class="line">       Chain chain = new RealInterceptorChain(interceptors, (StreamAllocation)null, (HttpCodec)null, (RealConnection)null, 0, this.originalRequest, this, this.eventListener, this.client.connectTimeoutMillis(), this.client.readTimeoutMillis(), this.client.writeTimeoutMillis());</span><br><span class="line">       // 开启链式调用(责任链模式)</span><br><span class="line">       return chain.proceed(this.originalRequest);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line">        StreamAllocation streamAllocation = new StreamAllocation(this.client.connectionPool(), this.createAddress(request.url()), call, eventListener, this.callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line">        // 如果未canceled则一直循环</span><br><span class="line">        while(!this.canceled) &#123;</span><br><span class="line">            boolean releaseConnection = true;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 责任链模式 调用下一个拦截器 并且捕获异常进行操作</span><br><span class="line">                response = realChain.proceed(request, streamAllocation, (HttpCodec)null, (RealConnection)null);</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">            &#125; catch (RouteException var19) &#123;</span><br><span class="line">                if (!this.recover(var19.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">                    throw var19.getFirstConnectException();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException var20) &#123;</span><br><span class="line">                boolean requestSendStarted = !(var20 instanceof ConnectionShutdownException);</span><br><span class="line">                if (!this.recover(var20, streamAllocation, requestSendStarted, request)) &#123;</span><br><span class="line">                    throw var20;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed((IOException)null);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder().priorResponse(priorResponse.newBuilder().body((ResponseBody)null).build()).build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            Request followUp;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 构建重定向请求</span><br><span class="line">                followUp = this.followUpRequest(response, streamAllocation.route());</span><br><span class="line">            &#125; catch (IOException var18) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw var18;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Util.closeQuietly(response.body());</span><br><span class="line">            ++followUpCount;</span><br><span class="line">            if (followUpCount &gt; 20) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!this.sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = new StreamAllocation(this.client.connectionPool(), this.createAddress(followUp.url()), call, eventListener, this.callStackTrace);</span><br><span class="line">                this.streamAllocation = streamAllocation;</span><br><span class="line">            &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 赋值为新的重定向请求</span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1L) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, Util.hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // gzip压缩</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = this.cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, this.cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 责任链模式 调用下一个拦截器</span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">        HttpHeaders.receiveHeaders(this.cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">        okhttp3.Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);</span><br><span class="line">        if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            // gzip解压</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder().removeAll(&quot;Content-Encoding&quot;).removeAll(&quot;Content-Length&quot;).build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        // cache利用DiskLruCache进行磁盘缓存</span><br><span class="line">        Response cacheCandidate = this.cache != null ? this.cache.get(chain.request()) : null;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        CacheStrategy strategy = (new Factory(now, chain.request(), cacheCandidate)).get();</span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">        if (this.cache != null) &#123;</span><br><span class="line">            this.cache.trackResponse(strategy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            Util.closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            return (new Builder()).request(chain.request()).protocol(Protocol.HTTP_1_1).code(504).message(&quot;Unsatisfiable Request (only-if-cached)&quot;).body(Util.EMPTY_RESPONSE).sentRequestAtMillis(-1L).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">        &#125; else if (networkRequest == null) &#123;</span><br><span class="line">            return cacheResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Response networkResponse = null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // 责任链模式 调用下一个拦截器</span><br><span class="line">                networkResponse = chain.proceed(networkRequest);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">                    Util.closeQuietly(cacheCandidate.body());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            if (cacheResponse != null) &#123;</span><br><span class="line">                if (networkResponse.code() == 304) &#123;</span><br><span class="line">                    response = cacheResponse.newBuilder().headers(combine(cacheResponse.headers(), networkResponse.headers())).sentRequestAtMillis(networkResponse.sentRequestAtMillis()).receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</span><br><span class="line">                    networkResponse.body().close();</span><br><span class="line">                    this.cache.trackConditionalCacheHit();</span><br><span class="line">                    this.cache.update(cacheResponse, response);</span><br><span class="line">                    return response;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Util.closeQuietly(cacheResponse.body());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response = networkResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();</span><br><span class="line">            if (this.cache != null) &#123;</span><br><span class="line">                if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">                    CacheRequest cacheRequest = this.cache.put(response);</span><br><span class="line">                    return this.cacheWritingResponse(cacheRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        this.cache.remove(networkRequest);</span><br><span class="line">                    &#125; catch (IOException var13) &#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        // 使用httpcodec处理请求,其实现类http1codec与http2codec分别对应着HTTP/1.1 和 HTTP/2 版本的实现</span><br><span class="line">        // httpcodec内部使用Okio对Socket的读写操作进行了封装,Okio对io以及nio进行了封装,可以进行更加便捷高效的io操作</span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(this.client, chain, doExtensiveHealthChecks);</span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line">        // 责任链模式 调用下一个拦截器</span><br><span class="line">        return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 使用httpcodec处理request获取response</span><br><span class="line">Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain)chain;</span><br><span class="line">        HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        RealConnection connection = (RealConnection)realChain.connection();</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        long sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">        httpCodec.writeRequestHeaders(request);</span><br><span class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line">        Builder responseBuilder = null;</span><br><span class="line">        if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</span><br><span class="line">            if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">                httpCodec.flushRequest();</span><br><span class="line">                realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">                responseBuilder = httpCodec.readResponseHeaders(true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseBuilder == null) &#123;</span><br><span class="line">                realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">                long contentLength = request.body().contentLength();</span><br><span class="line">                CallServerInterceptor.CountingSink requestBodyOut = new CallServerInterceptor.CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">                realChain.eventListener().requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">            &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpCodec.finishRequest();</span><br><span class="line">        if (responseBuilder == null) &#123;</span><br><span class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">        int code = response.code();</span><br><span class="line">        if (code == 100) &#123;</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">            response = responseBuilder.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();</span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        realChain.eventListener().responseHeadersEnd(realChain.call(), response);</span><br><span class="line">        if (this.forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0L) &#123;</span><br><span class="line">            throw new ProtocolException(&quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="发起异步请求"><a href="#发起异步请求" class="headerlink" title="发起异步请求"></a>发起异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 异步请求示例</span><br><span class="line">okHttpClient.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onFailure(Call call, IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(Callback responseCallback) &#123;</span><br><span class="line">        // 不允许重复调用</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (this.executed) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.executed = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.captureCallStackTrace();</span><br><span class="line">        this.eventListener.callStart(this);</span><br><span class="line">        this.client.dispatcher().enqueue(new RealCall.AsyncCall(responseCallback));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将请求加入到一个队列中</span><br><span class="line">void enqueue(AsyncCall call) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            this.readyAsyncCalls.add(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.promoteAndExecute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">boolean promoteAndExecute() &#123;</span><br><span class="line">        assert !Thread.holdsLock(this);</span><br><span class="line"></span><br><span class="line">        List&lt;AsyncCall&gt; executableCalls = new ArrayList();</span><br><span class="line">        boolean isRunning;</span><br><span class="line">        AsyncCall asyncCall;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            Iterator i = this.readyAsyncCalls.iterator();</span><br><span class="line"></span><br><span class="line">            while(true) &#123;</span><br><span class="line">                if (i.hasNext()) &#123;</span><br><span class="line">                    asyncCall = (AsyncCall)i.next();</span><br><span class="line">                    if (this.runningAsyncCalls.size() &lt; this.maxRequests) &#123;</span><br><span class="line">                        if (this.runningCallsForHost(asyncCall) &lt; this.maxRequestsPerHost) &#123;</span><br><span class="line">                            i.remove();</span><br><span class="line">                            executableCalls.add(asyncCall);</span><br><span class="line">                            this.runningAsyncCalls.add(asyncCall);</span><br><span class="line">                        &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                isRunning = this.runningCallsCount() &gt; 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = 0;</span><br><span class="line"></span><br><span class="line">        for(int size = executableCalls.size(); i &lt; size; ++i) &#123;</span><br><span class="line">            asyncCall = (AsyncCall)executableCalls.get(i);</span><br><span class="line">            // 在线程池中执行call的execute()方法</span><br><span class="line">            asyncCall.executeOn(this.executorService());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/mynameishuangshuai/article/details/51303446" target="_blank" rel="noopener">OkHttp官方教程解析-彻底入门OkHttp使用</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列：拆 OkHttp</a></li>
<li><a href="https://juejin.im/entry/597800116fb9a06baf2eeb63" target="_blank" rel="noopener">OkHttp解析</a> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/Glide源码详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/Glide源码详解/" itemprop="url">Glide源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-09T22:15:59+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文基于Glide 4.5.0版本</strong></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Volatile + Double-Checked Locking实现Glide的单例</span><br><span class="line">public static Glide get(@NonNull Context context) &#123;</span><br><span class="line">    if (glide == null) &#123;</span><br><span class="line">      synchronized (Glide.class) &#123;</span><br><span class="line">        if (glide == null) &#123;</span><br><span class="line">          checkAndInitializeGlide(context);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过构建者模式构造Glide</span><br><span class="line">Glide glide = builder.build(applicationContext);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// GlideBuilder的build方法返回Glide</span><br><span class="line">return new Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptions.lock(),</span><br><span class="line">        defaultTransitionOptions);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Glide的几个重要的构造参数如下:</p>
<ul>
<li><strong>arrayPool 数组池</strong></li>
<li><strong>memoryCache 内存缓存</strong></li>
<li><strong>bitmapPool 图片池</strong></li>
<li><strong>engine 引擎类</strong></li>
</ul>
<h2 id="ArrayPool"><a href="#ArrayPool" class="headerlink" title="ArrayPool"></a>ArrayPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定arrayPool则使用默认的Lru缓存策略</span><br><span class="line">if (arrayPool == null) &#123;</span><br><span class="line">      // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定memoryCache则使用默认的Lru缓存策略</span><br><span class="line">if (memoryCache == null) &#123;</span><br><span class="line">    // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">  memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BitmapPool"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定memoryCache则使用默认的缓存策略</span><br><span class="line">if (bitmapPool == null) &#123;</span><br><span class="line">      int size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">      if (size &gt; 0) &#123;</span><br><span class="line">      // 缓存池大小由MemorySizeCalculator决定</span><br><span class="line">        bitmapPool = new LruBitmapPool(size);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      // 不做缓存</span><br><span class="line">        bitmapPool = new BitmapPoolAdapter();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemorySizeCalculator"><a href="#MemorySizeCalculator" class="headerlink" title="MemorySizeCalculator"></a>MemorySizeCalculator</h2><h3 id="ArrayPool缓存池大小"><a href="#ArrayPool缓存池大小" class="headerlink" title="ArrayPool缓存池大小"></a>ArrayPool缓存池大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 缓存池大小取决于当前是否为低内存机型</span><br><span class="line">// 默认大小为4MB,如果当前为低内存机型则缓存池设为2MB</span><br><span class="line">arrayPoolSize =</span><br><span class="line">    isLowMemoryDevice(builder.activityManager)</span><br><span class="line">        ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR</span><br><span class="line">        : builder.arrayPoolSizeBytes;</span><br></pre></td></tr></table></figure>
<h3 id="BitmapPool与MemoryCache缓存池大小"><a href="#BitmapPool与MemoryCache缓存池大小" class="headerlink" title="BitmapPool与MemoryCache缓存池大小"></a>BitmapPool与MemoryCache缓存池大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取可用内存大小</span><br><span class="line">getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,</span><br><span class="line">      float lowMemoryMaxSizeMultiplier) &#123;</span><br><span class="line">    // 每个进程最大可用内存</span><br><span class="line">    final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;</span><br><span class="line">    final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);</span><br><span class="line">    // 如果是低内存手机 则最大内存*0.4 否则为最大内存*0.33</span><br><span class="line">    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier</span><br><span class="line">        : maxSizeMultiplier));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取屏幕宽度    </span><br><span class="line">int widthPixels = builder.screenDimensions.getWidthPixels();</span><br><span class="line">// 获取屏幕高度</span><br><span class="line">int heightPixels = builder.screenDimensions.getHeightPixels();</span><br><span class="line">// 当前屏幕宽度*屏幕高度*4</span><br><span class="line">int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;</span><br><span class="line">// 图片缓存池大小为屏幕尺寸大小*4(若当前版本大于等于Android O,则直接为屏幕尺寸大小*1)</span><br><span class="line">int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);</span><br><span class="line">// 内存缓存大小为屏幕尺寸大小*2</span><br><span class="line">int targetMemoryCacheSize = Math.round(screenSize *builder.memoryCacheScreens);</span><br><span class="line">// 可用内存为可用内存大小减去ArrayPool缓存池大小</span><br><span class="line">int availableSize = maxSize - arrayPoolSize;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否超过最大值,否则就等比缩小</span><br><span class="line">if (targetMemoryCacheSize + targetBitmapPoolSize &lt;= availableSize) &#123;</span><br><span class="line">      memoryCacheSize = targetMemoryCacheSize;</span><br><span class="line">      bitmapPoolSize = targetBitmapPoolSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      float part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">      memoryCacheSize = Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">      bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 若不指定engine则使用默认的engine</span><br><span class="line">if (engine == null) &#123;</span><br><span class="line">      engine =</span><br><span class="line">          new Engine(</span><br><span class="line">              memoryCache,</span><br><span class="line">              diskCacheFactory,</span><br><span class="line">              diskCacheExecutor,</span><br><span class="line">              sourceExecutor,</span><br><span class="line">              GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">              GlideExecutor.newAnimationExecutor(),</span><br><span class="line">              isActiveResourceRetentionAllowed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>engine的几个重要参数:</p>
<ul>
<li><strong>memoryCache 内存缓存</strong></li>
<li><strong>diskCacheFactory 本地缓存</strong></li>
<li><strong>diskCacheExecutor 本地缓存线程池</strong></li>
<li><strong>sourceExecutor 处理源资源线程池</strong></li>
</ul>
<h3 id="MemoryCache-1"><a href="#MemoryCache-1" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><p>同上。</p>
<h3 id="DiskCacheFactory"><a href="#DiskCacheFactory" class="headerlink" title="DiskCacheFactory"></a>DiskCacheFactory</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Factory &#123;</span><br><span class="line">  // 默认大小为250MB</span><br><span class="line">  int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 *</span><br><span class="line">  // 默认缓存目录为image_manager_disk_cache</span><br><span class="line">  String DEFAULT_DISK_CACHE_DIR = &quot;image_manager_disk_cache&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DiskCacheExecutor"><a href="#DiskCacheExecutor" class="headerlink" title="DiskCacheExecutor"></a>DiskCacheExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">newDiskCacheExecutor() &#123;</span><br><span class="line">    return newDiskCacheExecutor(</span><br><span class="line">    // 默认可获得处理器大小为1</span><br><span class="line">        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,</span><br><span class="line">        DEFAULT_DISK_CACHE_EXECUTOR_NAME,</span><br><span class="line">        UncaughtThrowableStrategy.DEFAULT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SourceExecutor"><a href="#SourceExecutor" class="headerlink" title="SourceExecutor"></a>SourceExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可获得处理器大小为当前可用处理器大小与4的最小值</span><br><span class="line">bestThreadCount =</span><br><span class="line">          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());</span><br></pre></td></tr></table></figure>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><h2 id="with的重载"><a href="#with的重载" class="headerlink" title="with的重载"></a>with的重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 返回一个RequestManager对象</span><br><span class="line">  * @see #with(android.app.Activity)</span><br><span class="line">  * @see #with(android.app.Fragment)</span><br><span class="line">  * @see #with(android.support.v4.app.Fragment)</span><br><span class="line">  * @see #with(android.support.v4.app.FragmentActivity)</span><br><span class="line">  */</span><br><span class="line"> @NonNull</span><br><span class="line"> public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">   return getRetriever(context).get(context);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步生命周期"><a href="#同步生命周期" class="headerlink" title="同步生命周期"></a>同步生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 通过传递Context类型的不同执行相似的逻辑</span><br><span class="line">RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">      if (context instanceof FragmentActivity) &#123;</span><br><span class="line">        return get((FragmentActivity) context);</span><br><span class="line">      &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">        return get((Activity) context);</span><br><span class="line">      &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">        return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 以传递Context类型为activity为例代码如下</span><br><span class="line">// 其他类型逻辑类似 都是获取FragmentManager</span><br><span class="line">get(@NonNull Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      return fragmentGet(activity, fm, null /*parentHint*/);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个无界面的Fragment,让请求和activity的生命周期同步</span><br><span class="line">fragmentGet(@NonNull Context context,</span><br><span class="line">      @NonNull android.app.FragmentManager fm,</span><br><span class="line">      @Nullable android.app.Fragment parentHint) &#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">      // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 如果在子线程调用或者传入Context类型为application,则请求与Application生命周期同步</span><br><span class="line">RequestManagerRetriever(@Nullable RequestManagerFactory factory) &#123;</span><br><span class="line">    this.factory = factory != null ? factory : DEFAULT_FACTORY;</span><br><span class="line">    handler = new Handler(Looper.getMainLooper(), this /* Callback */);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private RequestManager getApplicationManager(@NonNull Context context) &#123;</span><br><span class="line">    // Either an application context or we&apos;re on a background thread.</span><br><span class="line">    if (applicationManager == null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        if (applicationManager == null) &#123;</span><br><span class="line">          // Normally pause/resume is taken care of by the fragment we add to the fragment or</span><br><span class="line">          // activity. However, in this case since the manager attached to the application will not</span><br><span class="line">          // receive lifecycle events, we must force the manager to start resumed using</span><br><span class="line">          // ApplicationLifecycle.</span><br><span class="line"></span><br><span class="line">          // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  new ApplicationLifecycle(),</span><br><span class="line">                  new EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以加载文件图片为例,将返回一个RequestBuilder对象,支持链式调用</span><br><span class="line">RequestBuilder&lt;Drawable&gt; load(@Nullable File file) &#123;</span><br><span class="line">    return asDrawable().load(string);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="into"><a href="#into" class="headerlink" title="into"></a>into</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">into(@NonNull ImageView view) &#123;</span><br><span class="line">    // into方法必须要在主线程调用,否则抛出异常</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    RequestOptions requestOptions = this.requestOptions;</span><br><span class="line">    // 未调用transform而且设置了scaleType则会对图片做处理</span><br><span class="line">    if (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != null) &#123;</span><br><span class="line">      switch (view.getScaleType()) &#123;</span><br><span class="line">        case CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_CENTER:</span><br><span class="line">        case FIT_START:</span><br><span class="line">        case FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER:</span><br><span class="line">        case MATRIX:</span><br><span class="line">        default:</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return into(</span><br><span class="line">        // 将View封装为Target</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        /*targetListener=*/ null,</span><br><span class="line">        requestOptions);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">into(</span><br><span class="line">      @NonNull Y target,</span><br><span class="line">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">      @NonNull RequestOptions options) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    if (!isModelSet) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options = options.autoClone();</span><br><span class="line">    // 构建request</span><br><span class="line">    Request request = buildRequest(target, targetListener, options);</span><br><span class="line"></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    // 如果存在之前的相同请求而且未设置不允许内存缓存</span><br><span class="line">    if (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      // 释放当前request以及相关资源</span><br><span class="line">      request.recycle();</span><br><span class="line">      // 如果请求完成,将重新开始请求</span><br><span class="line">      // 如果请求正在运行,则继续运行</span><br><span class="line">      if (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        // 直接使用之前的请求来进行优化操作</span><br><span class="line">        // 例如跳过设置占位符,跟踪与取消跟踪目标,获取view尺寸</span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除target之前的request</span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    // 绑定request</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    // 跟踪request</span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runRequest(Request request) &#123;</span><br><span class="line">    // 加入request列表</span><br><span class="line">    requests.add(request);</span><br><span class="line">    if (!isPaused) &#123;</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 最终进入到Engine的load()</span><br><span class="line">// 尝试从ActiveResources中获取</span><br><span class="line">// ActiveResources中存放一个弱引用的map,存储使用中的资源,为了防止内存不足清除cache后不影响使用中的资源</span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    if (active != null) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">// 如果ActiveResources未能获取到则到MemoryCache中获取</span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 如果获取到则直接返回</span><br><span class="line">EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    if (current != null) &#123;</span><br><span class="line">      current.addCallback(cb);</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return new LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line">// 创建engineJob</span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line">            </span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    // 启动decodeJob</span><br><span class="line">    engineJob.start(decodeJob);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start(DecodeJob&lt;R&gt; decodeJob) &#123;</span><br><span class="line">    this.decodeJob = decodeJob;</span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">    // 尝试从磁盘中获取</span><br><span class="line">    // 磁盘获取的逻辑模式为先尝试获取处理后的图片然后尝试获取原图</span><br><span class="line">        ? diskCacheExecutor</span><br><span class="line">    // 从网络中获取</span><br><span class="line">        : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/08/Glide和Picasso对比/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/Glide和Picasso对比/" itemprop="url">Glide和Picasso对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-08T21:07:44+08:00">
                2018-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Glide和Picasso是目前Android开发中很流行的图片加载库，Glide库和Picasso库也有极大的相似性，其区别主要体现在如下几个方面。</p>
<h1 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h1><p>Glide库的大小要远远大于Picasso。<br><img src="http://pj8vo9ptw.bkt.clouddn.com/img_Glide%20%E5%92%8C%20Picasso%E5%AF%B9%E6%AF%94_1.png" alt="image"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>Glide支持gif</li>
<li>Glide支持视频略缩图</li>
<li>Glide支持与Acitivty生命周期联动</li>
<li>Glide默认加载<strong>RGB_565</strong>(2字节),Picasso默认加载<strong>ARGB8888</strong>(4字节)</li>
<li>Glide提供了更多配置可供定制化</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ul>
<li><strong>Picasso:</strong> 下载图片然后在本地缓存完整图片。如果需要resize,也是对原图进行resize。</li>
<li><strong>Glide:</strong> 下载图片,然后改变图片大小以适应不同需求,最后缓存到本地。同一张图片如果不同ImageView加载可能缓存多张图片。</li>
</ul>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>由于Glide缓存改变大小后的图片,而Picasso缓存原图,所以Glide使用的内存要小于Picasso。</p>
<h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><p>由于缓存机制的不同,Picasso从缓存中读取原图要先resize,而Glide则直接读取缓存图片,所以加载速度Glide优于Picasso。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/wait-notify机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/wait-notify机制/" itemprop="url">wait/notify机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T17:26:02+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="wait-notify机制介绍"><a href="#wait-notify机制介绍" class="headerlink" title="wait/notify机制介绍"></a>wait/notify机制介绍</h1><p>当一个线程A调用了对象o的wait()方法而进入了等待状态,而另一个线程B调用了对象o的notify()/notifyAll()方法,线程A收到通知退出等待队列,进入可执行状态。</p>
<h2 id="wait-notify机制的用处"><a href="#wait-notify机制的用处" class="headerlink" title="wait/notify机制的用处"></a>wait/notify机制的用处</h2><p>当两个线程存在生产者消费者关系,如果用轮询实现会造成资源的浪费,而wait/notify可以解决这个问题。</p>
<h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><ul>
<li><strong>notify():</strong> 随机唤醒等待队列中等待统一资源的一个线程,此线程会进入可运行状态</li>
<li><strong>notifyAll():</strong> 使所有等待队列中等待同一共享资源的线程退出等待队列,进入可运行状态</li>
<li><strong>wait():</strong> 调用该方法的线程释放锁并且从运行状态退出,进入等待队列,直到被唤醒</li>
<li><strong>wait(long):</strong> 超时等待一段时间,单位是毫秒,若超时没有被唤醒则返回</li>
<li><strong>wait(long, int):</strong> 单位是纳秒</li>
</ul>
<h1 id="wait-notify机制原理"><a href="#wait-notify机制原理" class="headerlink" title="wait/notify机制原理"></a>wait/notify机制原理</h1><h2 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h2><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_wait%E3%80%81notify%E6%9C%BA%E5%88%B6_1.png" alt="image"></p>
<ul>
<li><strong>新建:</strong> 新创建的线程对象</li>
<li><strong>可运行:</strong> 线程创建后,其start()方法被调用,位于可运行线程池中,等待获取cpu使用权</li>
<li><strong>运行:</strong> 可运行状态的线程获取了cpu时间片,执行代码</li>
<li><p><strong>阻塞:</strong> 线程因为某种原因放弃了cpu使用权,直到线程进入可运行状态</p>
<ul>
<li><strong>等待阻塞:</strong> 执行了waitt()方法, JVM将该线程放入等待队列中</li>
<li><strong>同步阻塞:</strong> 获取对象锁失败, JVM将该线程放入锁池(lock pool)中</li>
<li><strong>其他阻塞:</strong> 执行了sleep()方法,或者发出了I/O请求, JVM将该线程置为阻塞状态,当sleep()状态超时或者I/O处理完毕线程重新转入可运行状态</li>
</ul>
</li>
<li><p><strong>死亡:</strong> 线程的方法执行结束或者发生异常</p>
</li>
</ul>
<h2 id="wait-notify流程"><a href="#wait-notify流程" class="headerlink" title="wait/notify流程"></a>wait/notify流程</h2><ul>
<li>线程A获取对象锁并且进入同步代码块执行锁对象的wait()方法(立即释放锁),通知锁监听器,释放锁并且进入等待队列</li>
<li>线程B获取对象锁并且进入同步代码块执行锁对象的notify/notifyAll方法,告诉锁监听器,通知该对象锁的等待队列 <strong>(执行notify/notifyAll方法并不立即释放锁,只有退出同步代码块才释放对象锁)</strong></li>
<li>线程A得到锁监听器的通知,移出等待队列变成可运行状态,并且尝试获取锁执行代码</li>
</ul>
<h2 id="wait-notify与synchronized"><a href="#wait-notify与synchronized" class="headerlink" title="wait/notify与synchronized"></a>wait/notify与synchronized</h2><p>执行wait/notify必须要加synchronized锁,因为synchronized代码块生成的字节码中包含<strong>monitorenter</strong>与<strong>monitorexit</strong>指令。</p>
<p>monitorenter指令可以获取对象的monitor,而wait()方法的底层实现依赖于该对象的monitor,即如果在synchronized代码中执行,必定获取到了对象的monitor。</p>
<h2 id="wait-notify与cpu资源"><a href="#wait-notify与cpu资源" class="headerlink" title="wait/notify与cpu资源"></a>wait/notify与cpu资源</h2><p>wait/nofity是通过JVM里的<strong>park/unpark</strong>机制来实现的,在Linux下这种机制又是通过<br><strong>pthread_cond_wait/pthread_cond_signal</strong> 来实现的，因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/非对称加密以及RSA加密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/非对称加密以及RSA加密/" itemprop="url">非对称加密以及RSA加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T01:36:37+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密需要一对密钥,即公钥和私钥。如果使用公钥加密,则只能用对应私钥才能解密;而如果使用私钥加密,则只能使用对应公钥才能解密。</p>
<p>非对称加密主要是为了解决对称加密的<strong>密钥传输</strong>与<strong>密钥管理</strong>问题。</p>
<h2 id="非对称加密的工作方式"><a href="#非对称加密的工作方式" class="headerlink" title="非对称加密的工作方式"></a>非对称加密的工作方式</h2><p>客户端向服务端发送数据流程:</p>
<ul>
<li>服务端生成公钥和私钥</li>
<li>服务端发送公钥给客户端</li>
<li>客户端通过公钥加密数据</li>
<li>客户端发送密文给服务端</li>
<li>服务端通过私钥解密密文</li>
</ul>
<p>公钥和私钥都可以用来加密数据。</p>
<h2 id="非对称加密的优点"><a href="#非对称加密的优点" class="headerlink" title="非对称加密的优点"></a>非对称加密的优点</h2><ul>
<li>解决密钥传输问题</li>
<li>解决密钥管理问题</li>
</ul>
<h2 id="非对称加密的缺点"><a href="#非对称加密的缺点" class="headerlink" title="非对称加密的缺点"></a>非对称加密的缺点</h2><ul>
<li>运算量大</li>
<li>速度慢</li>
<li>适合少量数据加密长</li>
</ul>
<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><p>RSA是非对称加密算法的一种,为了保证加密的安全性,RSA密钥的长度一般都是1024位或者2048位,使得RSA加密的计算量大、速度慢。</p>
<h2 id="RSA加密原理"><a href="#RSA加密原理" class="headerlink" title="RSA加密原理"></a>RSA加密原理</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA加密原理(一)</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA加密原理(二)</a></p>
<h2 id="RSA注意事项"><a href="#RSA注意事项" class="headerlink" title="RSA注意事项"></a>RSA注意事项</h2><p>实际开发中,一般采用RSA+ASE相结合的方式。即使用AES加密数据,使用RSA加密AES的密钥。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/对称加密以及AES加密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/对称加密以及AES加密/" itemprop="url">对称加密以及AES加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T19:37:19+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密就是加密和解密使用同一个密钥的加密算法。</p>
<h2 id="对称加密的工作方式"><a href="#对称加密的工作方式" class="headerlink" title="对称加密的工作方式"></a>对称加密的工作方式</h2><ul>
<li>使用密钥加密明文数据</li>
<li>发送密文</li>
<li>收到密文</li>
<li>使用同一套密钥解密密文</li>
</ul>
<h2 id="对称加密的优点"><a href="#对称加密的优点" class="headerlink" title="对称加密的优点"></a>对称加密的优点</h2><ul>
<li>计算量小</li>
<li>速度快</li>
<li>适合大量数据加密</li>
</ul>
<h2 id="对称加密的缺点"><a href="#对称加密的缺点" class="headerlink" title="对称加密的缺点"></a>对称加密的缺点</h2><h3 id="密钥传输问题"><a href="#密钥传输问题" class="headerlink" title="密钥传输问题"></a>密钥传输问题</h3><p>由于对称加密使用同一个密钥,所以算法的安全性不仅仅取决于加密算法,更取决于密钥能否安全保管。</p>
<p>实际开发通常是客户端向服务端请求对称加密的密钥,密钥通过非对称加密后再传输。</p>
<h3 id="密钥管理问题"><a href="#密钥管理问题" class="headerlink" title="密钥管理问题"></a>密钥管理问题</h3><p>随着用户的增多,密钥的数量也随着膨胀。</p>
<h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h1><p>AES(Advanced Encryption Standard)是用来替代之前的DES加密算法而出现的。</p>
<p>AES加密算法使用分组密码体制,每个分组数据的长度为128位16个字节,密钥长度可以是128位16个字节、192位或者256位,一共有四种加密模式,我们通常采用需要初始向量IV的CBC模式,初始向量的长度为128位16个字节。</p>
<h2 id="AES的加密原理"><a href="#AES的加密原理" class="headerlink" title="AES的加密原理"></a>AES的加密原理</h2><h3 id="分组密码体制"><a href="#分组密码体制" class="headerlink" title="分组密码体制"></a>分组密码体制</h3><p>AES采用分组密码体制,将明文分段,每段长度为128位16字节。如果长度不够16字节,则要通过Padding将数据填满16字节,然后分别的每段数据加密,最后拼接成为密文。</p>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>Padding用来填充不满16字节的分组数据,有三种不同的填充模式。</p>
<ul>
<li><strong>PKCS5</strong>: 缺少n的字节,就在末尾填充n字节的n</li>
<li><strong>PKCS7</strong>: 末尾填充0</li>
<li><strong>NOPADDING</strong>: 发送方保证不需要填充</li>
</ul>
<p>解密需要使用和加密端相同的Padding,通常采用PKCS7 Padding。</p>
<h3 id="初始向量IV"><a href="#初始向量IV" class="headerlink" title="初始向量IV"></a>初始向量IV</h3><p>初始向量是为了使加密更加安全可靠,长度规定为128位16字节,初始向量来源为随机生成。</p>
<h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥的长度可以为128位16字节、192位或者256位,位数越高强度越大,但是效率更低。</p>
<p>通常采用128位16字节的密钥,密钥来源为随机生成。</p>
<h3 id="四种加密模式"><a href="#四种加密模式" class="headerlink" title="四种加密模式"></a>四种加密模式</h3><p>四种加密模式分别为ECB(电子密码本模式)、CBC(密码分组链接模式)、CFB以及OFB模式。</p>
<h2 id="AES的加密流程"><a href="#AES的加密流程" class="headerlink" title="AES的加密流程"></a>AES的加密流程</h2><h3 id="ECB-电子密码本模式"><a href="#ECB-电子密码本模式" class="headerlink" title="ECB(电子密码本模式)"></a>ECB(电子密码本模式)</h3><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8AAES%E5%8A%A0%E5%AF%86_1.png.png" alt="image"></p>
<p>ECB是最基本的加密模式,相同的明文块会被加密成相同的密文块,更容易破解,不安全,因为很少使用。</p>
<h3 id="CBC-密码分组链接模式"><a href="#CBC-密码分组链接模式" class="headerlink" title="CBC(密码分组链接模式)"></a>CBC(密码分组链接模式)</h3><p><img src="http://pj8vo9ptw.bkt.clouddn.com/img_%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8AAES%E5%8A%A0%E5%AF%86_2.png" alt="image"></p>
<ul>
<li>AES将明文按128位16字节分割,如果最后一块不够则通过Padding填充</li>
<li>然后将明文块0与初始向量IV进行异或操作,再用密钥加密,得到密文块0,同时密文块0作为明文块1的加密向量</li>
<li>然后明文块1与密文块0进行异或,再用密钥加密得到密文块1</li>
<li>最后将所有密文块拼接得到密文</li>
</ul>
<h2 id="AES的注意事项"><a href="#AES的注意事项" class="headerlink" title="AES的注意事项"></a>AES的注意事项</h2><ul>
<li>服务端与客户端使用相同的<strong>密钥</strong></li>
<li>服务端与客户端使用相同的<strong>初始向量IV</strong></li>
<li>服务端与客户端使用相同的<strong>加密模式</strong> </li>
<li>服务端与客户端使用相同的<strong>Padding</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/Hash算法以及MD5/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Hash算法以及MD5/" itemprop="url">Hash算法以及MD5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T18:32:37+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MD5(Message Digest Algorithm MD5)是一种Hash算法,严格来说并不是一种加密算法,但是可以达到加密的效果。</p>
<h1 id="MD5算法的优点"><a href="#MD5算法的优点" class="headerlink" title="MD5算法的优点"></a>MD5算法的优点</h1><h2 id="容易计算以及不可逆"><a href="#容易计算以及不可逆" class="headerlink" title="容易计算以及不可逆"></a>容易计算以及不可逆</h2><ul>
<li>主流编程语言基本都支持MD5算法的实现</li>
<li>MD5是一个不可逆的算法,无法通过MD5值逆推原文</li>
</ul>
<h2 id="压缩性"><a href="#压缩性" class="headerlink" title="压缩性"></a>压缩性</h2><ul>
<li>任意长度的数据的MD5值都是一个32位长度的十六进制字符串,区分大小写</li>
</ul>
<h2 id="抗修改性"><a href="#抗修改性" class="headerlink" title="抗修改性"></a>抗修改性</h2><ul>
<li>原文即便是微小的修改,MD5也会有巨大的变动</li>
</ul>
<h2 id="抗碰撞性"><a href="#抗碰撞性" class="headerlink" title="抗碰撞性"></a>抗碰撞性</h2><ul>
<li>MD5共有2的128次方种可能性,实际中找到两个相同的MD5值是非常困难的</li>
</ul>
<h1 id="MD5算法的缺点"><a href="#MD5算法的缺点" class="headerlink" title="MD5算法的缺点"></a>MD5算法的缺点</h1><ul>
<li>安全性</li>
</ul>
<h1 id="MD5算法的场景"><a href="#MD5算法的场景" class="headerlink" title="MD5算法的场景"></a>MD5算法的场景</h1><h2 id="用户信息存储"><a href="#用户信息存储" class="headerlink" title="用户信息存储"></a>用户信息存储</h2><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>为了预防数据库泄露带来的严重后果,数据库中不应存放用户私密数据的明文。</p>
<h3 id="MD5的弊端-彩虹表"><a href="#MD5的弊端-彩虹表" class="headerlink" title="MD5的弊端(彩虹表)"></a>MD5的弊端(彩虹表)</h3><p>彩虹表是一个庞大的数据库,存放着常用的密码以及对应的MD5、SHA-X等Hash值，如果密码较为简单就有可能被彩虹表破译掉。</p>
<h3 id="正确的加密方法-salt"><a href="#正确的加密方法-salt" class="headerlink" title="正确的加密方法(salt)"></a>正确的加密方法(salt)</h3><p>加盐:在密码的任意位置插入一些特殊的字符串(salt)的过程。</p>
<p>加盐是为了增强密码的复杂性,从而降低了密码被彩虹表破译的概率。</p>
<p>加盐的要求:</p>
<ul>
<li>每个用户的salt最好具有唯一性</li>
<li>salt最好由服务器为每个用户随机生成</li>
<li>撒盐的方法最好复杂一点</li>
</ul>
<h3 id="实际开发流程"><a href="#实际开发流程" class="headerlink" title="实际开发流程"></a>实际开发流程</h3><p>服务端进行加盐操作:</p>
<ul>
<li>客户端对password进行MD5</li>
<li>通过接口传递加密后的数据</li>
<li>服务端MD5(客户端传递的加密数据 + salt)</li>
<li>服务端保存数据</li>
</ul>
<h2 id="生成数字签名"><a href="#生成数字签名" class="headerlink" title="生成数字签名"></a>生成数字签名</h2><p>微信支付通过MD5生成数字签名</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Dawn</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/delaube" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="lu923418335@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawn</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
